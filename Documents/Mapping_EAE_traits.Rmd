---
title: "EAE"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
bibliography: eae.bib
---

## Introduction
The purpose of this workflow is to start getting into data 
sent by Dimitry Krementsov and his graduate studen Emily Holt 
at UVM.

They are interested in the genetics of multiple sclerosis (MS).
The mouse model of MS is called [experimental autoimmune 
enchephalomyelitis (EAE)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3229753/).
In this model, mice are injected with CNS antigens which cause
development of autoimmunity. 

The Krementsov lab is inducing EAE in a panel of CC mice 
to investigate the effect of genetic backgroud on this model.
So far they have identified multiple types of EAE that mirror
the human experience better than the standard model. Whereas
the classic mouse model displays a progressive form of ascending
paralysis, the diverse model has relapsing remitting patterns
of disease, as well as axial-rotory (AR) EAE. These patterns are
also seen in humans, but the genetics of the heterogeneity of 
MS in humans has not been well studied.

In this study, we will try to map genetic variants that 
are associated with subtypes of EAE. We will also use TRiAGE
to prioritize genes within the mapped loci.

## Collecting and Processing Data

From the Excel file that Emily sent, I saved the CDS_Individuals
tab as a csv file. I copied and pasted the body of the data table
into a new excel file and saved it as a csv file. I then programatically
deleted the empty row separating the founders and the CC lines and
removed all slashes from strain names so that "C57BL/6" and "C57BL6" 
match.

I also copied the Incidence tab to three csv files as I did above. 
The files are named with the following pattern:

* incidence_female_month_year.csv - incidence calculations for all females of each strain
* incidence_male_month_year.csv - incidence calculations for all males of each strain
* incidence_strain_month_year.csv - incidence calculations for each strain including both sexes

```{r get_arguments}
rm(list = ls())

#===============================================================
#I'm hard-coding final parameters for now
#===============================================================
#args <- commandArgs(trailingOnly=T)
#b6_correction <- as.logical(args[1]) #Use B6 score to do batch correction
#batch_as_covar <- as.logical(args[2]) #use batch as a covariate
#rank_norm <- as.logical(args[3]) #whether to rank Z normalize adjusted scores.
#===============================================================



#===============================================================
#hard code the final decisions on corrections and normalizations
#set final_param to FALSE to use the arguments again
#===============================================================
final_param = TRUE

if(final_param){
    b6_correction <- FALSE
    batch_as_covar <- TRUE
    rank_norm <- TRUE
}
#===============================================================

genotypes <- c("MRCA", "sequenced")
genotypes <- genotypes[2]

if(is.na(b6_correction) || length(b6_correction) == 0){
b6_correction = FALSE; batch_as_covar = FALSE; rank_norm = FALSE
}

if(b6_correction && batch_as_covar){stop("Set either b6_correction or batch_as_covar to TRUE, not both.")}

alpha <- c(0.15, 0.2)
```

```{r load_code}
library(here)

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}

overwrite_previous <- FALSE
add_founder_genotypes <- FALSE

#strains identified by remove_strains are excluded from all 
#manipulations including normalization and batch corrections.
#justficiations are as follows:
#CC027 - all but 2 were homozygous for the wrong genotype at the H2 locus
#NOD and 129 - are not used for mapping, and were not included in all
#batches, so we cannot use them for normalization
#remove_strains <- NULL
remove_strains <- c("CC027", "NOD", "129") 
#remove_strains <- c("CC051", "CC059") #closely related
#remove_strains <- c("CC051") #pick one of them to keep

cc.color.scheme = "original"
#cc.color.scheme = "new"

exclude.zeros = FALSE #if true, we exclude animals with a CDS of 0
disease.thresh = 0 #maximum disease score considered disease-free

cds.file.date = "December_2023" #date for CDS csv file to use in format month_year
inc.file.date = "December_2023" #date for incidence csv files to use in format month_year

nperm = 1000

if(nperm > 0){
    run_permutations <- TRUE
}else{
    run_permutations <- FALSE
}
```

## Parameters

```{r param_text}
if(add_founder_genotypes){
    founders.included = "yes"
}else{
    founders.included = "no"
}

if(length(remove_strains) > 0){
    strains.removed <- paste(remove_strains, collapse = ", ")
}else{
    strains.removed = "none"
}

if(!exclude.zeros){
    zero.text <- "Zeros are included in CDS"
    zero.treatment <- "included with"
}else{
    zero.text <- paste("Animals with scores of", disease.thresh, "and below are excluded from CDS.")
    zero.treatment <- "excluded from"
}

if(b6_correction){
    correction.text <- "Batch corrections were made using B6 CDS."
    correction.label <- "B6-batch"
}
if(batch_as_covar){
    correction.text <- "Batch corrections were done using batch as a covariate."
    correction.label <- "covar-batch"
}
if(!b6_correction && !batch_as_covar){
    correction.text <- "No batch corrections were done."
    correction.label <- "no-batch"
}

if(rank_norm){
    norm.text <- "Rank Z normalization was performed."
    norm.label <- "rank-norm"
}else{
    norm.text <- "Rank Z normalization was not performed."
    norm.label <- "no-norm"
}

file.label <- paste(correction.label, norm.label, genotypes, sep = "_")
```

The parameters for this run are as follows:

* Genotypes used: `r genotypes`

* Founders included: `r founders.included`

* CC Strains removed: `r strains.removed`

* Treatment of zeros: `r zero.text`

* Batch correction: `r correction.text`

* Normalization: `r norm.text`

```{r results_dir}
results.dir <- here("Results", paste("Zeros", strsplit(zero.treatment, " ")[[1]][1], file.label, sep = "_"))
if(!file.exists(results.dir)){dir.create(results.dir)}
```

```{r load_libraries, warning = FALSE, message = FALSE, error = FALSE}
all.packages <- c("pheatmap", "qtl2", "ggplot2", "abind", "igraph", "knitr", "parallel",
    "stringr", "grid")
load_libraries(all.packages)
cores = detectCores()-1
```

Read in phenotype data.

```{r load_data}
if(cc.color.scheme == "original"){
    strain.colors <- CCorigcolors
}else{
    strain.colors <- CCcolors
}

cds <- read.csv(here("Data", paste0("CDS_", cds.file.date, ".csv")), strip.white = TRUE)
incidence.files <- get.files(path = here("Data"), want = c(inc.file.date, "incidence"), 
    full.names = TRUE)
incidence <- lapply(incidence.files, function(x) as.matrix(read.csv(x, row.names = 1, strip.white = TRUE)))
names(incidence) <- gsub(".txt", "", basename(incidence.files))

#take out any slashes in strain names in cds
cds[,"Strain"]  <- gsub("/", "", cds[,"Strain"], fixed = TRUE)
```

This run uses the CDS file from `r gsub("_", " ", cds.file.date)`.

And the incidence files from `r gsub("_", " ", inc.file.date)`.

## Remove excluded strains

If any strains need to be removed from the analysis, do 
that now before any numbers are manipulated.

```{r remove_strains}
#remove any empty rows that were inserted to visually separate
#the founders from the rest of the strains
cds.data.idx <- which(!is.na(cds[,"ID"]))
cds <- cds[cds.data.idx,]

for(i in 1:length(incidence)){
    inc.data.idx <- which(!is.na(incidence[[i]][,1]))
    incidence[[i]] <- incidence[[i]][inc.data.idx,]
}


#remove specified sterains from cds and incidence
if(length(remove_strains) != 0){
    remove.cds <- unlist(sapply(remove_strains, function(x) which(cds[,"Strain"] == x)))
    cds <- cds[-remove.cds,]

    for(i in 1:length(incidence)){
        remove.incidence <- unlist(sapply(remove_strains, function(x) which(rownames(incidence[[i]]) == x)))
        incidence[[i]] <- incidence[[i]][-remove.incidence,]
    }
}
```


```{r batches}
num.cds <- as.matrix(cds[,c("Classical.CDS", "AR.CDS", "Global.CDS")])
rownames(num.cds) <- cds[,"ID"]
#set all scores equal to or lower than the disease threshold
#to zero
if(exclude.zeros){
    num.cds[which(num.cds <= disease.thresh)] <- 0
}

factor.cds <- as.matrix(cds[,c("Strain", "Sex")])
u_batch <- unique(cds[,"EXP"])

#remove animals in batch 170 - these were validation, not part of the original experiment
to.remove = "X170" 
keep.batch <- which(u_batch != "X170")
u_batch <- u_batch[keep.batch]

keep.idx <- which(cds[,"EXP"] != "X170")
cds <- cds[keep.idx,]
num.cds <- num.cds[keep.idx,]
factor.cds <- factor.cds[keep.idx,]

batch.mat <- matrix(0, nrow = nrow(cds), ncol = length(u_batch))
colnames(batch.mat) <- u_batch
for(b in 1:ncol(batch.mat)){
    batch.mat[which(cds[,"EXP"] == u_batch[b]),b] <- 1
}
cds.covar <- as.matrix(cbind(batch.mat, cds[,"Age.at.D0",drop=FALSE]))

pheno.strains <- cds[,"Strain"]
eae.strains <- unique(pheno.strains)
```

## Samples by strain

The following heatmap shows how many individuals are in 
each strain by sex combination.

```{r sample_counts, fig.width = 8, fig.height = 1.5}
count.table <- table(cds[,c("Sex", "Strain")])
strain.order <- c(3:ncol(count.table), 1,2)
par(mar = c(1,4,4,2))
imageWithText(count.table[,strain.order], use.pheatmap.colors = TRUE, 
    col.text.shift = -1.4, row.text.shift = -2, col.text.adj = 0,
    col.text.cex = 0.7, cex = 0.8, row.text.adj = 0.5)
```

## CDS Distribution {.tabset .tabset-fade .tabset-pills}

Each day of the study, each mouse is given a disease CDS 
score between 0 and 5, with lower numbers indicating less 
disease. The cumulative disease score (CDS) for a given mouse
is the sum of these scores over the course of the study.

The distributions of three scores are shown below. Classical
is the classical presentation of paralysis used in the field.
AR (axial rotary) scores an alternate form of paralysis.
Global is the sum of the Classical and AR scores and gives
an overall score of disease regardless of type. 

```{r zeros, fig.width = 8, fig.height = 8}
par(mfrow = c(2,2))
for(i in 1:ncol(num.cds)){
    hist(num.cds[,i], breaks = 50, main = colnames(num.cds)[i], 
    xlab = colnames(num.cds)[i])
}
```

There are many mice that never display measurable symptoms
and have cumulative disease scores of 0. This kind of floor
effect causes problems with statistical tests that assume
a normal distribution.

If exclude.zeros is set to TRUE, these 0 values will be
excluded from CDS mapping.

In this analysis `r zero.text`.

The plots below show the CDS distribution by strain.

```{r cds, results = "asis", fig.width = 10, fig.height = 5}

plot_cds_by_strain <- function(scores, strain.labels, exclude.zeros = TRUE,
    ymin = NULL, ymax = NULL, plot.label = ""){
    
    u_strain <- unique(strain.labels)
    strain.idx <- lapply(u_strain, function(x) which(strain.labels == x))

    if(exclude.zeros){
        nonzero.idx <- which(scores != 0)
    }else{
        nonzero.idx <- 1:length(scores)
    }
    strain.cds <- lapply(strain.idx, function(x) scores[intersect(nonzero.idx, x)])
    names(strain.cds) <- u_strain
    strain.order <- order(sapply(strain.cds, mean))

    if(is.null(ymax)){ymax = max(scores, na.rm = TRUE)}
    if(is.null(ymin)){
        ymin = min(scores, na.rm = TRUE)
        #if(ymin > 0){ymin <- 0}
    }

    #quartz(width = 10, height = 5)
    layout(matrix(c(1,2), ncol = 2), width = c(1, 0.5))
    par(mar = c(4,4,4,0))
    stripchart(strain.cds[strain.order], vertical = TRUE, pch = 16, 
        col = "gray", method = "jitter", las = 2, ylim = c(ymin, ymax),
        main = paste(plot.label, "cds"), ylab = "CDS")
    a <- hist(unlist(strain.cds), plot = FALSE)
    par(mar = c(4,0,4,2))
    plot.new()
    plot.window(xlim = c(0, max(a$counts)), ylim = c(ymin, ymax))
    segments(x0 = rep(0, length(a$counts)), x1 = a$counts, y0 = a$mids, 
        lwd = 10, col = "gray")
    #text(x = a$counts+2, y = a$mids, labels = a$counts, adj = 0, cex = 0.7)
    mtext("Individual Counts", side = 3)
    axis(1)

    invisible(strain.cds)
}

for(cd in 1:ncol(num.cds)){
    cat("###", colnames(num.cds)[cd], "\n")
    temp.vals <- plot_cds_by_strain(scores = num.cds[,cd], 
        strain.labels = factor.cds[,"Strain"], exclude.zeros = exclude.zeros,
        ymax = max(num.cds), plot.label = colnames(num.cds)[cd])
    cat("\n\n")
}
```

## Batch Effects

The individuals were run in multiple batches, which can 
cause systematic biases in the data. We need to correct
any batch effects that we find before we map.

The following heatmap shows how the different 
strains and sexes were represented in different 
batches. The males and females are shown separately.

```{r batch_assortment, fig.width = 5, fig.height = 7}
batch.list <- vector(mode = "list", length = length(u_batch))
for(b in 1:length(u_batch)){
    batch.idx <- which(cds.covar[,b] == 1)
    batch.mat <- matrix(0, nrow = length(eae.strains), ncol = 2)
    rownames(batch.mat) <- eae.strains
    batch.table <- table(data.frame(factor.cds[batch.idx,]))
    batch.mat[match(rownames(batch.table), eae.strains),] <- batch.table
    colnames(batch.mat) <- paste(colnames(cds.covar)[b], colnames(batch.table), sep = "_")
    batch.list[[b]] <- batch.mat
}
all.batch.counts <- Reduce("cbind", batch.list)
imageWithText(all.batch.counts, use.pheatmap.colors = TRUE, col.text.shift = -38.5,
col.text.rotation = 45, col.text.adj = 0, cex = 0.7)
```

The following boxplots show the batch values for the B6 
animals. These show that the batches had an increase in 
CDS across the batches.

```{r b6_batch, fig.width = 8, fig.height = 8, eval = FALSE}
b6.idx <- which(factor.cds[,1] == "C57BL6")
if(exclude.zeros){
    nonzero.idx <- lapply(1:ncol(num.cds), function(x) which(num.cds[,x] != 0))
}else{
    nonzero.idx <- lapply(1:ncol(num.cds), function(x) 1:nrow(num.cds))
}
b6.batch.idx <- apply(cds.covar[,1:(ncol(cds.covar)-1)], 2, 
    function(x) intersect(which(x == 1), b6.idx))

par(mfrow = c(2,2))
b6.by.batch <- vector(mode = "list", length = ncol(num.cds))
names(b6.by.batch) <- colnames(num.cds)
for(cd in 1:ncol(num.cds)){
    #get batch values for this CDS
    vals.by.batch <- lapply(1:length(b6.batch.idx), 
        function(x) num.cds[intersect(b6.batch.idx[[x]], nonzero.idx[[cd]]),cd])
    names(vals.by.batch) <- u_batch
    b6.by.batch[[cd]] <- vals.by.batch
    boxplot(b6.by.batch[[cd]], main = colnames(num.cds)[cd])    
}

```


### Batch correction procedure

The B6 batch correction procedure is as follows:

1. Calculate the overall mean CDS for B6 mice 
    across the entire experiment
2. Calculate the mean CDS B6 mice in each batch.
3. Adjust all mice in each batch based on the
    difference in means in the B6. Subtract off 
    the mean deviation, and divide by the standard
    deviation.
4. Male and female B6 mice do not have a sex 
    difference in CDS, and adjusting by the 
    two sexes separately could inadvertently 
    introduce a sex effect into the other strains,
    so we use overall means rather than sex-specific 
    means.

The batch correction procedure using batch as a covariate is as follows:

1. Create a binary matrix indicating whether each individual
    was run in each batch (1) or not (0).
2. Regress this matrix out of the CDS matrix.


### Remove batch effects {.tabset .tabset-fade .tabset-pills}

```{r adj_cds}
#choose which phenotypes to batch 
#correct using their indices.
cds.idx <- c(1,2,3) 
```

Adjust for batch. We adjusted the following traits for batch effects:
`r cat(colnames(num.cds)[cds.idx], sep = "\n")`

```{r no_adj}
adj.cds <- num.cds 
```

```{r adj_batch_covar}
if(batch_as_covar){
    adj.cds <- adjust(num.cds, cds.covar[,1:ncol(cds.covar)-1])
}
```

```{r mean_sd}

if(b6_correction){
    batch.mean <- sapply(b6.by.batch, function(x) sapply(x, mean))
    batch.sd <- sapply(b6.by.batch, function(x) sapply(x, sd))
    batch.sd[which(is.na(batch.sd))] <- 1

    #for each batch
    for(b in c(1:(ncol(cds.covar)-1))){
        batch.idx <- which(cds.covar[,b] == 1)
        for(j in cds.idx){ #only correct classical and global
            if(exclude.zeros){
                    nonzero.idx <- which(num.cds[,j] != 0)
                }else{
                    nonzero.idx <- 1:nrow(num.cds)
                }
            adj.idx <- intersect(batch.idx, nonzero.idx)
            adj.cds[adj.idx,j] <- (num.cds[adj.idx,j] - batch.mean[b,j])/batch.sd[b,j]
        }
    }
    
}
```


### Age at D0 {.tabset .tabset-fade .tabset-pills}

Another one of our covariates is Age.at.D0.

The following boxplot shows that age varies significantly 
by batch.

```{r age_by_batch}
age <- cds.covar[,ncol(cds.covar)]
age.by.batch <- lapply(1:(ncol(cds.covar)-1), function(x) age[which(cds.covar[,x] == 1)])
p.val <- aov.by.list(age.by.batch)$"Pr(>F)"[1]

boxplot(age.by.batch, main = paste("Age at D0 by batch\n", "p =", signif(p.val, 2)))
stripchart(age.by.batch, vertical = TRUE, method = "jitter", pch = 16, 
    col = "#756bb1", add = TRUE)
```

The following plots show the relationship between Age.at.D0
and each CDS after adjusting for batch.

```{r age_at_day0, results = "asis", fig.width = 8, fig.height = 8}

u_age <- unique(cds.covar[,"Age.at.D0"])
age.idx <- lapply(u_age, function(x) which(cds.covar[,"Age.at.D0"] == x))
cds.by.age <- lapply(age.idx, function(x) adj.cds[x,,drop=FALSE])

par(mfrow = c(2,2))
for(i in 1:3){
    just.one <- lapply(cds.by.age, function(x) x[,i])
    x.vals <- lapply(1:length(just.one), function(x) rep(u_age[x], length(just.one[[x]])))
    x <- unlist(x.vals)
    y <- unlist(just.one)
    if(exclude.zeros){
        nonzero.idx <- which(y != 0)
    }else{
        nonzero.idx <- 1:length(y)
    }

    plot.with.model(x[nonzero.idx], y[nonzero.idx], xlab = "Age at D0", 
        ylab = colnames(num.cds)[i], main = colnames(num.cds)[i])
}
```


```{r adjust_age, eval = FALSE}
#adjust for age
for(i in 1:ncol(adj.cds)){
    if(exclude.zeros){
        nonzero.idx <- which(num.cds[,i] != 0)
    }else{
        nonzero.idx <- 1:nrow(num.cds)
    }
    adj.cds[nonzero.idx,i] <- adjust(adj.cds[nonzero.idx,i,drop=FALSE], 
        cds.covar[nonzero.idx,"Age.at.D0",drop=FALSE])
}
```

```{r write_adj}
#write out the results of whatever adjustments we have done
write.table(adj.cds, file.path(results.dir, "Adj_CDS.csv"), sep = ",", quote = FALSE)
```

Rank Z normalize the CDS scores if this is specified.

```{r no_norm}
norm.cds <- adj.cds
colnames(norm.cds) <- gsub(".CDS", "", colnames(norm.cds)) #take off CDS in labels, to save room in plots
```

```{r norm}
if(rank_norm){
    for(i in 1:ncol(norm.cds)){
        if(exclude.zeros){
            nonzero.idx <- which(num.cds[,i] != 0)
        }else{
            nonzero.idx <- 1:nrow(num.cds)
        }
        norm.cds[nonzero.idx,i] <- rankZ(adj.cds[nonzero.idx,i])
    }
}
colnames(norm.cds) <- gsub(".CDS", "", colnames(norm.cds)) #take off CDS, to save room in plots

#write out normzliaed values
write.table(norm.cds, file.path(results.dir, "Norm_CDS.csv"), sep = ",", quote = FALSE)

```

### Normalized Scores {.tabset .tabset-fade .tabset-pills}

The following plots show the distribution of each 
disease score after adjustments and normalization.

```{r norm_dist, fig.width = 10, fig.height = 5, results = "asis"}
#ymin = min(norm.cds);ymax = max(norm.cds) #all on same axes
ymin = NULL; ymax = NULL #all on independend axes
for(cd in 1:ncol(norm.cds)){
    cat("####", colnames(norm.cds)[cd], "\n")
    plot_cds_by_strain(scores = norm.cds[,cd], 
        strain.labels = factor.cds[,"Strain"], exclude.zeros = exclude.zeros,
        ymin = ymin, ymax = ymax, plot.label = colnames(num.cds)[cd])
    cat("\n\n")
}

```

## CC genotypes

I downloaded the CC genotypes from the UNC website:
http://csbio.unc.edu/CCstatus/CCGenomes/#genotypes

I downloaded the Most Recent Common Ancestor file. 
This has marker names from the mega muga. I downloaded the
mega muga marker map from the Jackson Laboratory 
[resource for CC/DO mice](https://www.jax.org/research-and-faculty/genetic-diversity-initiative/tools-data/diversity-outbred-reference-data)

```{r MRCA_genotypes, warning = FALSE}
cc.geno <- readRDS(here("Data", "MRCA10_modelprobs_trim.rds"))

if(genotypes == "MRCA"){

    marker.info.file <- here("Data", "mouse", "mm_uwisc_v1.csv")
    marker.info <- read.csv(marker.info.file)

    #convert the map and the genoprobs into a qtl2 object
    cross_obj <- array2qtl2(cc.geno, marker.info, chr = c(1:19, "X"), chr.col = "chr", 
        pos.col = "bp_mm10", crosstype = "risib8")

    cc.genoprobs <- cross_obj$genoprobs
    map <- cross_obj$map

    K <- calc_kinship(cc.genoprobs, "loco")
}
```


```{r sequenced_genotypes}

if(genotypes == "sequenced"){
    map.file <- here("Data", "map.RDS")
    new.geno.file <- here("Data", "genoprobs.RDS")
    k.file <- here("Data", "kinship_loco.RDS")

    if(!file.exists(map.file)){
        file <- paste0("https://raw.githubusercontent.com/rqtl/", "qtl2data/master/CC/cc.zip")
        cc <- read_cross2(file)
        map <- cc$pmap
        saveRDS(map, map.file)
        
        cc.official <- rownames(cc$geno[[1]])
        cc.alias <- sapply(strsplit(cc.official, "/"), function(x) x[1])
        write.table(cbind(cc.official, cc.alias), here("Data", "CC_names.txt"), sep = "\t", 
            quote = FALSE, row.names = FALSE, col.names = FALSE)
        
        cc.genoprobs <- calc_genoprob(cc, cores = cores)    
        new.genoprobs <- cc.genoprobs

        #add strains 83 and 84 to the genoprobs from the MRCA genotypes
        new.strains <- c("CC083", "CC084")
        new.strain.idx <- match(new.strains, rownames(cc.geno))
        for(i in 1:length(cc.genoprobs)){
            chr.markers <- dimnames(cc.genoprobs[[i]])[[3]]
            common.markers <- intersect(chr.markers, dimnames(cc.geno)[[3]])
            orig.idx <- match(common.markers, dimnames(cc.genoprobs[[i]])[[3]])
            new.idx <- match(common.markers, dimnames(cc.geno)[[3]])
            new.chr <- abind(cc.genoprobs[[i]][,,orig.idx], cc.geno[new.strain.idx,,new.idx], along = 1)
            new.genoprobs[[i]] <- new.chr
        }
        saveRDS(new.genoprobs, new.geno.file)

        #overwrite the original objecct
        cc.genoprobs <- new.genoprobs

        K <- calc_kinship(new.genoprobs, "loco")
        saveRDS(K, k.file)
    }else{
        map <- readRDS(map.file)
        cc.genoprobs <- readRDS(new.geno.file)
        K <- readRDS(k.file)
    }
}
```

If specified, add genoptypes for 129, NOD, and B6, so we 
can use them in mapping.

```{r add_other_strains}
if(add_founder_genotypes){
    founder_fun <- function(strain.name){
        founder.genotypes <- rep(0, length(strain.colors))
        founder.idx <- which(names(strain.colors) == strain.name)
        founder.genotypes[founder.idx] <- 1
        return(founder.genotypes)
    }

    strain.129 <- founder_fun("129")
    strain.b6 <- founder_fun("B6")
    strain.nod <- founder_fun("NOD")

    mapping.genoprobs  <- cc.genoprobs
    for(i in 1:length(cc.genoprobs)){
        ind.129 <- matrix(strain.129, nrow = ncol(cc.genoprobs[[i]]), 
            ncol = dim(cc.genoprobs[[i]])[3])
        ind.b6 <- matrix(strain.b6, nrow = ncol(cc.genoprobs[[i]]), 
            ncol = dim(cc.genoprobs[[i]])[3])
        ind.nod <- matrix(strain.nod, nrow = ncol(cc.genoprobs[[i]]), 
            ncol = dim(cc.genoprobs[[i]])[3])
        new.chr <- abind(cc.genoprobs[[i]], ind.129, ind.b6, ind.nod, along = 1)
        rownames(new.chr)[tail(1:length(rownames(new.chr)), 3)] <- c("129", "C57BL6", "NOD")
        mapping.genoprobs[[i]] <- new.chr
    }

    #recalculate K for the new genoprobs.
    mapping.K <- calc_kinship(mapping.genoprobs, "loco")
    mapping.strains <- eae.strains
}else{
    mapping.genoprobs <- cc.genoprobs
    mapping.K <- K
    mapping.strains <- eae.strains[grep("CC", eae.strains)]
}
```

## Allele Frequencies {.tabset .tabset-fade .tabset-pills}

The following plots show the frequencies of each founder 
allele across each chromosome. Regions in which the allele
frequencies are imbalanced may not be good for mapping.

```{r allele_freq, results = "asis", fig.width = 8, fig.height = 4}
allele_freq <- lapply(mapping.genoprobs, function(x) apply(x, 3, colMeans))
for(ch in 1:length(allele_freq)){
    cat("### Chr", names(map)[[ch]], "\n")
    layout(matrix(c(1,2), nrow = 1), widths = c(1,0.3))
    par(mar = c(4,4,4,0))
    plot.new()
    plot.window(xlim = c(0, max(map[[ch]])), ylim = c(0,0.4))
    for(a in 1:nrow(allele_freq[[ch]])){
        points(map[[ch]][dimnames(mapping.genoprobs[[ch]])[[3]]], 
        allele_freq[[ch]][a,], col = strain.colors[a], type = "l", lwd = 2)
    }
    abline(h = 0)
    axis(1)
    axis(2)
    mtext(paste("Chr", names(map)[[ch]]))
    plot.new()
    plot.window(xlim = c(0,1), ylim = c(0,1))
    par(mar = c(4,0,4,0))
    legend(x = 0, y = 1, lty = 1, col = strain.colors, legend = names(strain.colors), 
        horiz = FALSE, bg = "white", lwd = 2, adj = 0)
    cat("\n\n")
}
```

## Sex Effects Plotted by Individual {.tabset .tabset-fade .tabset-pills}

The following plots show the trait distributions for each
strain. Each plot is ordered by overall strain mean.

For each strain, the dots are split and colored by sex. 
Each point represents one mouse. The horizontal line
shows the mean value for that sex. This helps show
where there might be sex effects in individual strains.


```{r trait_fun}
#This function puts the given trait into a list based
#on strain and plots it if desired.
trait_list <- function(strain.tables, trait.name, exclude.zeros = TRUE, 
    col.by = NULL, plot.results = TRUE){

    if(length(col.by) == 0){col.by = rep("gray", sum(sapply(strain.tables, nrow)))}
    if(length(col.by) == 1){col.by = rep(col.by, sum(sapply(strain.tables, nrow)))}
    u_cols <- unique(col.by)

    if(length(u_cols) > 1){
        col.seg <- segment.region(-0.15, 0.15, length(u_cols), "ends")
    }else{
        col.seg <- 0
    }

    strain.trait <- lapply(strain.tables, function(x) x[,trait.name])
    names(strain.trait) <- names(strain.tables)

    if(exclude.zeros){
        #remove 0, to do CDS only
        nonzero.idx <- which(unlist(strain.trait) != 0) #find indices to remove from other variables
        strain.trait <- lapply(strain.trait, function(x) x[which(x != 0)]) #remove zeros
    }else{
        nonzero.idx <- 1:length(unlist(strain.trait))
    }
    col.by <- col.by[nonzero.idx]

    trait.mean <- sapply(strain.trait, mean)
    trait.order <- order(trait.mean)

    plot.idx <- unlist(lapply(1:length(strain.trait), function(x) rep(x, length(strain.trait[[x]]))))

    if(plot.results){
        ymin <- min(unlist(strain.trait), na.rm = TRUE)
        ymax <- max(unlist(strain.trait), na.rm = TRUE)

        plot.new()
        plot.window(xlim = c(1,length(strain.tables)), ylim = c(ymin, ymax))
        x <- 1
        for(i in trait.order){
            #plot the colors separately so we can see them better
            for(j in 1:length(u_cols)){
                ind.idx <- which(plot.idx == i)
                col.idx <- which(col.by[ind.idx] == u_cols[j])
                points(rep(x+col.seg[j], length(col.idx)), 
                    strain.trait[[i]][col.idx], col = u_cols[j], pch = 16)
                points(x+col.seg[j], 
                    mean(strain.trait[[i]][col.idx]), col = u_cols[j], pch = "-", cex = 2)
                #segments(x0 = x+col.seg[j], y0 = ymin, y1 = ymax, col = u_cols[j])
                segments(x0 = x+0.5, y0 = ymin, y1 = ymax, col = "gray")
            }
            x <- x + 1
        }
        axis(2)
        par(xpd = TRUE)
        text(x = 1:length(strain.trait), y = rep(ymin, length(strain.trait)), 
            labels = names(strain.trait)[trait.order], srt = 90, adj = 1)
        par(xpd = FALSE)
        mtext(trait.name, side = 3, line = 2, font = 2)
        #stripchart(strain.trait[trait.order], vertical = TRUE, pch = 16, method = "jitter", las = 2, main = trait.name, ylab = trait.name)
    }
    return(strain.trait)
}

#This function plots the mean by the col.by argument
#and tests for statistical differences between these
#means. It returns a vector of p values, one for each
#strain.
trait_bars <- function(strain.tables, trait.name, exclude.zeros = TRUE,
    col.by = NULL, plot.results = TRUE){

    if(length(col.by) == 0){col.by = rep("gray", sum(sapply(strain.tables, nrow)))}
    if(length(col.by) == 1){col.by = rep(col.by, sum(sapply(strain.tables, nrow)))}
    u_cols <- unique(col.by)
    col.seg <- segment.region(-0.15, 0.15, length(u_cols), "ends")

    strain.trait <- lapply(strain.tables, function(x) x[,trait.name])
    names(strain.trait) <- names(strain.tables)

    if(exclude.zeros){
        #remove 0, to do CDS only
        nonzero.idx <- which(unlist(strain.trait) != 0) #find indices to remove from other variables
        strain.trait <- lapply(strain.trait, function(x) x[which(x != 0)]) #remove zeros
    }else{
        nonzero.idx <- 1:length(unlist(strain.trait))
    }
    col.by <- col.by[nonzero.idx]

    trait.mean <- sapply(strain.trait, mean)
    trait.order <- order(trait.mean)

    plot.idx <- unlist(lapply(1:length(strain.trait), function(x) rep(x, length(strain.trait[[x]]))))
    diff.p <- rep(NA, length(strain.tables))
    names(diff.p) <- names(strain.tables)[trait.order]
    
    if(plot.results){
        ymin <- min(unlist(strain.trait), na.rm = TRUE)
        ymax <- max(unlist(strain.trait), na.rm = TRUE)

        plot.new()
        plot.window(xlim = c(1,length(strain.tables)), ylim = c(ymin, ymax))
        x <- 1
        for(i in trait.order){
            #plot the colors separately so we can see them better
            test.diff <- vector(mode = "list", length = length(u_cols))
            for(j in 1:length(u_cols)){
                ind.idx <- which(plot.idx == i)
                col.idx <- which(col.by[ind.idx] == u_cols[j])
                points(x+col.seg[j], 
                    mean(strain.trait[[i]][col.idx]), col = u_cols[j], type = "h",
                    lwd = 3)
                test.diff[[j]] <- strain.trait[[i]][col.idx]
                #segments(x0 = x+col.seg[j], y0 = ymin, y1 = ymax, col = u_cols[j])
                segments(x0 = x+0.5, y0 = ymin, y1 = ymax, col = "gray")
            }
            if(all(sapply(test.diff, length) > 1)){
                test <- aov.by.list(test.diff)
                diff.p[x] <- test[1,"Pr(>F)"]
            }
            x <- x + 1
        }
        axis(2)
        par(xpd = TRUE)
        text(x = 1:length(strain.trait), y = rep(ymin, length(strain.trait)), 
            labels = names(strain.trait)[trait.order], srt = 90, adj = 1)
        par(xpd = FALSE)
        mtext(trait.name, side = 3, line = 2, font = 2)
        abline(h = 0)
        #stripchart(strain.trait[trait.order], vertical = TRUE, pch = 16, method = "jitter", las = 2, main = trait.name, ylab = trait.name)
    }
    return(diff.p)
}
```

```{r trait_dist}
strain.tables <- lapply(mapping.strains, function(x) norm.cds[which(cds[,1] == x),])
strain.factors <- lapply(mapping.strains, function(x) factor.cds[which(cds[,1] == x),])
names(strain.tables) <- names(strain.factors) <- mapping.strains
```

### Classical

```{r dots_classical, fig.width = 10, fig.height = 5}
sex.col <- as.numeric(as.factor(unlist(lapply(strain.factors, function(x) x[,"Sex"]))))

strain.classical <- trait_list(strain.tables, "Classical", col.by = sex.col+2, 
    exclude.zeros = exclude.zeros)
legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
    bg = "white")
```

### AR

```{r dots_ar, fig.width = 10, fig.height = 5}
strain.ar  <- trait_list(strain.tables, "AR", col.by = sex.col+2,
    exclude.zeros = exclude.zeros)
legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
    bg = "white")
```

### Global

```{r dots_global, fig.width = 10, fig.height = 5}
strain.global <- trait_list(strain.tables, "Global",col.by = sex.col+2, 
    exclude.zeros = exclude.zeros)
legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
    bg = "white")
```

## Sex Effects by Strain {.tabset .tabset-fade .tabset-pills}

The following plots distill the above figures to just the 
means for each sex. This makes it easier to see where the
means for the two sexes are different. 

An imbalance of sex effects in the different strains could
lead to strange mapping patterns (I think).

The top plot for each shows the means for each sex and each
strain. The strains are ordered by overall strain mean.

The middle plot shows the -log10 of the p value for each 
difference. The solid line shows the p = 0.05 threshold,
and the dashed line shows the bon ferroni adjust p value
threshold.

The bottom dot plot shows a direct comparison of 
female means vs. male means for each strain and 
each trait. Strains with a large difference between
male and female (90th percentile) are labeled.

Overall there is no difference between the sexes.
However, a few strains have large sex biases. 
For CC044, CC075, and CC072, females tend to have a
larger disease score. For CC042, the males tend to
have a larger disease score.

### Classical

```{r plot_bars_fun}

plot_bars <- function(trait.name, exclude.zeros){
    layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.5))
    par(mar = c(3,4,4,4))
    classical.p <- trait_bars(strain.tables, trait.name, col.by = sex.col+2, 
        exclude.zeros = exclude.zeros)
    legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
        bg = "white")
    par(mar = c(4,3.5,0,3.5))
    p.thresh <- c(-log10(0.05), -log10(0.05/length(strain.tables)))
    ymax <- max(c(p.thresh, -log10(classical.p)), na.rm = TRUE)
    ymax <- ceiling(ymax*1)/1
    a <- barplot(-log10(classical.p), las = 2, ylim = c(0, ymax))
    mtext("-log10(p) for sex difference", side = 2, line = 2.5)
    segments(x0 = rep(0, length(p.thresh)), x1 = rep(max(a[,1]), length(p.thresh)), 
        y0 = p.thresh, lty = c(1,2))
    par(xpd = TRUE)
    text(x = max(a[,1]), y = -log10(0.05), labels = "0.05", adj = 0)
    text(x = max(a[,1]), y = -log10(0.05/length(strain.tables)), labels = "corrected", adj = 0)
    par(xpd = FALSE)
}
```

```{r plot_dots}
plot_dots <- function(trait.name, diff.percentile = 90){

    f.vals <- lapply(1:length(strain.factors), function(x) strain.tables[[x]][which(strain.factors[[x]][,"Sex"] == "F"),trait.name])
    m.vals <- lapply(1:length(strain.factors), function(x) strain.tables[[x]][which(strain.factors[[x]][,"Sex"] == "M"),trait.name])

    f.means <- sapply(f.vals, mean)
    m.means <- sapply(m.vals, mean)

    diffs <- abs(f.means - m.means)
    diff.thresh <- get.percentile(diffs, diff.percentile)
    big.diffs <- which(diffs >= diff.thresh)

    plot(f.means, m.means, pch = 16, xlab = "Female Mean", ylab = "Male Mean",
    main = trait.name)
    abline(0,1)
    text(f.means[big.diffs], m.means[big.diffs], labels = names(strain.factors)[big.diffs],
        pos = 2)
    
}
```

```{r bars_classical, fig.width = 10, fig.height = 7}
plot_bars("Classical", exclude.zeros = exclude.zeros)
```

```{r dots_comp_classical}
plot_dots("Classical")
```


### AR

```{r bars_ar, fig.width = 10, fig.height = 7}
plot_bars("AR", exclude.zeros = exclude.zeros)
```

```{r dots_comp_ar}
plot_dots("AR")
```


### Global

```{r bars_global, fig.width = 10, fig.height = 7}
plot_bars("Global", exclude.zeros = exclude.zeros)
```

```{r dots_comp_global}
plot_dots("Global")
```


### Overall Sex Effect

```{r sex_diff, fig.height = 8, fig.width = 8}
#quartz(width = 8, height = 8)
par(mfrow = c(2,2))
for(i in 1:ncol(norm.cds)){
    if(exclude.zeros){
        nonzero.idx <- which(norm.cds[,i] != 0)
    }else{
        nonzero.idx <- 1:nrow(norm.cds)
    }
    model <- lm(norm.cds[nonzero.idx,i]~as.factor(factor.cds[nonzero.idx,"Sex"]))
    f <- summary(model)$fstatistic
    p <- pf(f[1],f[2],f[3],lower.tail=F)
    boxplot(norm.cds[nonzero.idx,i]~as.factor(factor.cds[nonzero.idx,"Sex"]), 
        ylab = colnames(norm.cds)[i],
        main = paste(colnames(norm.cds)[i], "\np =", signif(p, 2)), xlab = "")
}
```

## CDS Trait Correlations

The following plot shows that global CDS
is dominated by classical disease.
It also shows that CDS in classical 
disease and AR are unrelated to each other.

```{r trait_cor, fig.width = 8, fig.height = 8}
trait.pairs <- pair.matrix(1:ncol(norm.cds))
par(mfrow = c(2,2))
for(i in 1:nrow(trait.pairs)){
    trait1 <- trait.pairs[i,1]
    trait2 <- trait.pairs[i,2]
    if(exclude.zeros){
        nonzero.idx <- intersect(which(norm.cds[,trait1] != 0), which(norm.cds[,trait2] != 0))
    }else{
        nonzero.idx <- 1:nrow(norm.cds)
    }
    plot.with.model(norm.cds[nonzero.idx,trait1], norm.cds[nonzero.idx,trait2],
        xlab = colnames(norm.cds)[trait1], ylab = colnames(norm.cds)[trait2],
        main = paste(colnames(norm.cds)[trait1], "vs.", colnames(norm.cds)[trait2]))
}
```

## Map CDS with Individuals

We mapped each CDS across the individual mice. 

```{r methods}
if(add_founder_genotypes){
    methods.line <- "Both CC and founder strains were used for mapping."
}else{
    methods.line <- "We used only CC strains for mapping."
}

if(length(remove_strains) != 0){
    remove.line <- paste("We excluded the following strains:", paste(remove_strains, collapse = ", "))
}else{
    remove.line <- "No CC strains were excluded."
}
```

`r methods.line`
`r remove.line`

For the genoprobs and kinship matrices, we copied
the entries for the individuals in each strain and
used indices for row names.

The LOD traces for each trait are shown below along 
with plots for the FDR results. Significance thresholds
from the permutations are also shown on the LOD traces.

```{r expand_matrices}

#remove any strains not used in mapping
mapping.strain.idx <- unlist(sapply(mapping.strains, function(x) grep(x, pheno.strains)))
pheno.strains <- pheno.strains[mapping.strain.idx]

#make a unique ID for each mouse that contains its strain and sex
u_id <- as.vector(apply(cds[mapping.strain.idx,c(1:2,5)], 1, function(x) paste(x, collapse = "_")))

K.idx <- sapply(mapping.strains, function(x) grep(x, rownames(mapping.K[[1]])))
K.num <- sapply(mapping.strains, function(x) length(which(pheno.strains == x)))
expanded.idx <- unlist(lapply(1:length(K.idx), function(x) rep(K.idx[x], K.num[x])))
groups <- names(expanded.idx)

exp.K <- lapply(1:length(mapping.K), function(x) mapping.K[[x]][expanded.idx,expanded.idx])
names(exp.K) <- names(mapping.K)

#create unique row and column names
for(i in 1:length(exp.K)){
    rownames(exp.K[[i]]) <- colnames(exp.K[[i]]) <- 1:length(u_id)
}

expanded.genoprobs <- mapping.genoprobs
for(i in 1:length(expanded.genoprobs)){
    expanded.genoprobs[[i]] <- mapping.genoprobs[[i]][expanded.idx,,]
    rownames(expanded.genoprobs[[i]]) <- 1:length(u_id)
}

#align the phenotypes with the strains
covar <- matrix(as.numeric(as.factor(cds[mapping.strain.idx,"Sex"])), ncol = 1)
rownames(covar) <- 1:length(u_id)

mapping.pheno <- norm.cds[mapping.strain.idx,]
rownames(mapping.pheno) <- 1:length(u_id)

mapping.factors <- factor.cds[mapping.strain.idx,]
mapping.covar <- matrix(as.numeric(as.factor(mapping.factors[,"Sex"])), ncol = 1)
rownames(mapping.covar) <- 1:length(u_id)
```

### Heritability

The heritability of CDS is shown below.

```{r herit, fig.width = 5, fig.height = 5}
overall.k.file <- here("Data", "kinship_overall.RDS")
if(!file.exists(overall.k.file) || overwrite_previous){
    overall.K <- calc_kinship(expanded.genoprobs, "overall")
    saveRDS(overall.K, overall.k.file)
}else{
    overall.K <- readRDS(overall.k.file)
}

ind.herit <- rep(NA, ncol(num.cds))
names(ind.herit) <- colnames(num.cds)
for(i in 1:ncol(num.cds)){
    nonzero.idx <- which(mapping.pheno[,i] != 0)
    ind.herit[i] <- est_herit(mapping.pheno[nonzero.idx,i,drop=FALSE], overall.K)
}

barplot_with_num(round(ind.herit, 2), ylab = "Heritability", xlab = "", 
    ylim = c(0, 0.4), text.shift = 0.09, main = "Trait Heritability Estimates")
```

```{r mapping_fun}
#We have run into problems with extremely small variance
#in genotype probabilities leading to large LOD scores.
#round.digs attempts to solve this by rounding all 
#genotype probabilities to the specified number of 
#significant figures. All CC lines should be either 1 or
#0 at every locus, so 2 digits should be sufficient to 
#get any errant heterozygotes, but also squash out very
#small variations
map_pheno <- function(map.geno, map.pheno, map.K, addcovar = NULL,
    intcovar = NULL, groups = NULL, exclude.zeros = TRUE, 
    round.digs = 2,
    results.file = file.path(results.dir, "scan1_results.RDS")){

    if(!file.exists(results.file) || overwrite_previous){

        #round the genotypes so low-variance markers don't lead
        #to large QTL LOD scores
        rounded.geno <- map.geno
        for(chr in 1:length(rounded.geno)){
            rounded.geno[[chr]] <- round(map.geno[[chr]], round.digs)
        }

        pheno.scans <- vector(mode = "list", length = ncol(map.pheno))
        names(pheno.scans) <- colnames(map.pheno)
        for(ph in 1:ncol(map.pheno)){
            if(exclude.zeros){
                nonzero.idx <- which(map.pheno[,ph] != 0)
            }else{
                nonzero.idx <- 1:nrow(map.pheno)
            }

            pheno.scans[[ph]] <- scan1(rounded.geno, map.pheno[nonzero.idx,ph], 
                addcovar = addcovar, intcovar = intcovar, kinship = map.K)
            #plot(pheno.scans[[ph]], map = map)
        }
        saveRDS(pheno.scans, results.file)
    }else{
        pheno.scans <- readRDS(results.file)
    }
    return(pheno.scans)
}


perm_scans <- function(map.geno, map.pheno, map.k, scan1.results, 
    addcovar = NULL, intcovar = NULL, groups = NULL, nperm = nperm, 
    max.exp.lod = 20, n.founders = 8, exclude.zeros = TRUE, 
    results.file = file.path(results.dir, "perm.RDS"), round.digs = 2){

    #permutations for Matt's FDR method (see https://github.com/j-matthew-mahoney/cdf-fdrci.git)
    #right now this does one phenotype at a time, but we can change that later.
    perm.data <- vector(mode = "list", length = ncol(map.pheno))
    nind = nrow(map.pheno)
    #bin possible LOD scores
    breaks = lod2p(seq(max.exp.lod, 0, -0.01), nind = nind, k = n.founders)

    #round the genotypes to get rid of very small variances that
    #lead to large QTL LOD scores
    rounded.geno <- map.geno
    for(chr in 1:length(rounded.geno)){
        rounded.geno[[chr]] <- round(map.geno[[chr]], round.digs)
    }

    if(!file.exists(results.file)){
        for(ph in 1:ncol(map.pheno)){
            if(exclude.zeros){
                nonzero.idx <- which(map.pheno[,ph] != 0)
            }else{
                nonzero.idx <- 1:nrow(map.pheno)
            }
            if(!is.null(groups)){
                null_stats = scan1_groupperm_stats(rounded.geno, 
                    pheno = map.pheno[nonzero.idx,ph,drop=FALSE], 
                    groups = groups[nonzero.idx],
                    kinship = map.k, nperm = nperm, breaks = breaks, 
                    addcovar = addcovar, intcovar = intcovar,
                    scan1_out = scan1.results[[ph]][,1,drop=FALSE], cores = cores)
            }else{
                null_stats = scan1perm_stats(rounded.geno, 
                    pheno = map.pheno[nonzero.idx,ph,drop=FALSE], 
                    kinship = map.k, nperm = nperm, breaks = breaks,
                    addcovar = addcovar, intcovar = intcovar,
                    scan1_out = scan1.results[[ph]][,1,drop=FALSE], cores = cores)
            }
            perm.data[[ph]] <- null_stats
        }
        saveRDS(perm.data, results.file)
    }else{
        perm.data <- readRDS(results.file)
    }
    return(perm.data)
}

#plots LOD traces with significance thresholds and returns a matrix
#with traits in rows and the different significance thresholds for
#LOD scores in columns corresponding to both standard and FDR-adjusted 
#LOD scores.
plot_fdr_fun <- function(scan.results, perm.results, tab.level = "###", maxy = NULL){

    fdr_summaries <- matrix(NA, nrow = length(scan.results), ncol = 5)
    rownames(fdr_summaries) <- names(scan.results)
    for(ph in 1:length(scan.results)){
        cat(tab.level, names(scan.results)[ph], "\n")
        summary_thresholds = fdr_summarize(null_stats = perm.results[[ph]], 
            fdr_cl = 0.95, geno_sig = alpha, fdr_thresh = c(0.1, 0.2, 0.4), 
            plot = FALSE, quartz = FALSE)

        finite.thresh <- which(is.finite(summary_thresholds))

        if(is.null(maxy)){
            maxy <- max(c(scan.results[[ph]][,1], 
                summary_thresholds[finite.thresh], na.rm = TRUE))*1.1
        }
        par(mar = c(4, 4, 4, 2))
        plot(scan.results[[ph]], map = map, main = names(scan.results)[ph], 
            ylim = c(0, maxy))
        abline(h = summary_thresholds, lty = 1:length(summary_thresholds))
        plot.dim <- par("usr")
        par(xpd = TRUE)
        #text(x = plot.dim[2], y = summary_thresholds[finite.thresh], 
        #    labels = names(summary_thresholds)[finite.thresh], cex = 0.5, adj = 0)
        text(x = plot.dim[2]*1.01, y = summary_thresholds[finite.thresh], 
            labels = alpha, cex = 0.5, adj = 0)

        #text(x = plot.dim[1], y = summary_thresholds[finite.thresh],
        #    labels = summary_thresholds[finite.thresh], cex = 0.7, adj = 1)
        par(xpd = FALSE)
        fdr_summaries[ph,] <- summary_thresholds
        cat("\n\n")
    }
    colnames(fdr_summaries) <- names(summary_thresholds)
    invisible(fdr_summaries)
}

#This function is similar to above, but uses permutation results
#from qtl2's scan1perm, rather than the fdr scan.
plot_pval_fun <- function(scan.results, perm.results, tab.level = "###"){

    sig_summaries <- t(summary(perm.results, alpha = alpha))
    finite.thresh <- which(is.finite(sig_summaries))
    #fdr_summaries <- matrix(NA, nrow = length(scan.results), ncol = length(alpha))
    #rownames(fdr_summaries) <- names(scan.results)
    #colnames(fdr_summaries) <- paste0("FDR ", alpha*100, "%")

    for(ph in 1:length(scan.results)){
        cat(tab.level, names(scan.results)[ph], "\n")

        trait.p <- lod2p(scan.results[[ph]][,1], nind = attr(scan.results[[ph]], "sample_size"), k = 8)
        trait.fdr <- p.adjust(trait.p, "fdr")
        #plot(scan.results[[ph]][,1], trait.fdr, ylim = c(0,1))
        #abline(h = alpha)
        
        fdr.idx <- lapply(alpha, function(x) which(round(trait.fdr, 2) == x))
        fdr.thresh <- unlist(lapply(fdr.idx, function(x) if(length(x) > 0){scan.results[[ph]][x]}else{NA}))
        #fdr_summaries[ph,] <- fdr.thresh

        maxy <- max(c(scan.results[[ph]][,1], 
            sig_summaries[ph,], na.rm = TRUE))*1.1
        par(mar = c(4, 4, 4, 8))
        plot(scan.results[[ph]], map = map, main = names(scan.results)[ph], 
            ylim = c(0, maxy))
        abline(h = sig_summaries[ph,], lty = c(1,2))
        #abline(h = fdr_summaries[ph,])
        plot.dim <- par("usr")
        par(xpd = TRUE)
        text(x = plot.dim[2]*1.005, y = sig_summaries[ph,], 
            labels = colnames(sig_summaries), cex = 0.7, adj = 0)
        par(xpd = FALSE)
        cat("\n\n")
    }
    #sig_summaries <- cbind(sig_summaries, fdr_summaries)
    sig_summaries <- cbind(sig_summaries)
    invisible(sig_summaries)
}

select_threshold <- function(scan.results, fdr_summaries){
    for(ph in 1:length(scan.results)){
        finite.thresh <- fdr_summaries[ph,which(is.finite(fdr_summaries[ph,]))]
        peak.tables <- lapply()
    }
}

allele_coef <- function(map.geno, map.pheno, map.k, addcovar = NULL,
    intcovar = NULL, scan.results, lod.threshold, exclude.zeros, 
    chr.lod.file, chr.coef.file, round.digs = 2){

    peak.table <- lapply(1:length(scan.results), 
        function(x) find_peaks(scan.results[[x]], map = map, 
        threshold = lod.threshold[x]))

    #round genotypes to reduce risk of low-variance alleles
    #leading to large QTL LOD scores
    rounded.geno <- map.geno
    for(chr in 1:length(rounded.geno)){
        rounded.geno[[chr]] <- round(map.geno[[chr]], round.digs)
    }

    if(!file.exists(chr.lod.file) || overwrite_previous){
        chr.lod <- chr.coef <- vector(mode = "list", length = nrow(Reduce("rbind", peak.table)))
        idx = 1
        for(ph in 1:length(peak.table)){
            if(nrow(peak.table[[ph]]) != 0){
                for(p in 1:nrow(peak.table[[ph]])){
                    chr <- peak.table[[ph]][p,"chr"]
                    peak.loc <- peak.table[[ph]][p,"pos"]
                    trait = names(scan.results)[ph]
                    chr.locale <- which(names(map.geno) == chr)

                    if(exclude.zeros){
                        nonzero.idx <- which(map.pheno[,ph] != 0)
                    }else{
                        nonzero.idx <- 1:nrow(map.pheno)
                    }

                    chr.scan <- scan1(rounded.geno[,chr], 
                        map.pheno[nonzero.idx,ph,drop=FALSE], 
                        kinship = map.k[[chr.locale]], addcovar = addcovar,
                        intcovar = intcovar)
                    chr.lod[[idx]] <- chr.scan
                    #plot(chr.scan, map = map);abline(v = peak.loc)

                    effects.scan <- scan1blup(rounded.geno[,chr], 
                        map.pheno[nonzero.idx,ph,drop=FALSE], 
                        kinship = map.k[[chr.locale]], addcovar = addcovar)
                    chr.coef[[idx]] <- effects.scan
                    #plot_coefCC(effects.scan, map = map);abline(v = peak.loc)
                    idx = idx + 1 #increment regardless of whether there is a peak here
                }
                
            }
        }
        saveRDS(chr.lod, chr.lod.file)
        saveRDS(chr.coef, chr.coef.file)
    }else{
        chr.lod <- readRDS(chr.lod.file)
        chr.coef <- readRDS(chr.coef.file)
    }
    result <- list("peak.table" = peak.table, "LOD" = chr.lod, "Coef" = chr.coef)
    return(result)
}

plot_coef_scans <- function(coef.results, map.geno, map.pheno, fdr_results = NULL,
    tab.level = "###", sig_lines = c("Genome-wide", "FDR")){
    
    if(!is.null(fdr_results)){
        sig_lines = sig_lines[1]
        line.idx <- grep(sig_lines, colnames(fdr_results))
    }

    peak.table <- coef.results$peak.table
    chr.lod <- coef.results$LOD
    chr.coef <- coef.results$Coef

    idx <- 1
    for(ph in 1:length(peak.table)){
        if(nrow(peak.table[[ph]]) != 0){
            for(p in 1:nrow(peak.table[[ph]])){
                par(mfrow = c(2,1))
                chr <- peak.table[[ph]][p,"chr"]
                trait <- colnames(map.pheno)[ph]
                peak.loc <- peak.table[[ph]][p,"pos"]
                chr.locale <- which(names(map.geno) == chr)
                
                cat(tab.level, trait, "Chr", chr, "\n")

                if(!is.null(fdr_results)){
                    ymax <- max(c(chr.lod[[idx]], fdr_results[ph,line.idx]))
                }else{
                    ymax <- max(chr.lod[[idx]])
                }
                plot(chr.lod[[idx]], map = map, main = paste(trait, "Chr", chr), 
                    ylim = c(0, ymax*1.05))
                if(!is.null(fdr_results)){
                    abline(h = fdr_results[ph,line.idx], lty = ph)
                
                    plot.dim <- par("usr")
                    par(xpd = TRUE)
                    text(x = plot.dim[2], y = fdr_results[ph,line.idx], 
                        labels = gsub(paste0(sig_lines, " "), "", colnames(fdr_results)[line.idx]), 
                        cex = 0.5, adj = 0)
                }
                par(xpd = FALSE)


                plot_coefCC(chr.coef[[idx]], map = map, main = paste(trait, "Chr", chr),
                    col = strain.colors)
                abline(v = peak.loc, lwd = 2)

                idx = idx + 1
                cat("\n\n")
            }
        }
    }
}

```

```{r map_cds, warning = FALSE}

cds.scans <- map_pheno(expanded.genoprobs, mapping.pheno, exp.K, 
    addcovar = covar, exclude.zeros = exclude.zeros, 
    results.file = file.path(results.dir, "scan1_results_cds.RDS"))



if(run_permutations){
    #perm_strata <- names(expanded.idx)
    #names(perm_strata) <- rownames(mapping.pheno)
    #cds.perm <- scan1perm(expanded.genoprobs, mapping.pheno, kinship = exp.K, 
    #    addcovar = covar, perm_strata = perm_strata, n_perm = nperm, cores = detectCores()-1)

    #cds.perm <- scan1perm(expanded.genoprobs, mapping.pheno, kinship = exp.K, 
    #    addcovar = covar, n_perm = nperm, cores = detectCores()-1)

    cds.perm <- perm_scans(expanded.genoprobs, mapping.pheno, exp.K,
        cds.scans, addcovar = covar, groups = names(expanded.idx), 
        exclude.zeros = exclude.zeros, nperm = nperm, 
        results.file = file.path(results.dir, "scan1perm_results_cds_perm_scans.RDS"))
}
```


```{r by_sex}
nperm = 100
f.idx <- which(covar[,1] == 1)
m.idx <- which(covar[,1] == 2)

strain.strata <- names(expanded.idx)
names(strain.strata) <- rownames(mapping.pheno)

cds.f.scans <- map_pheno(expanded.genoprobs, mapping.pheno[f.idx,], exp.K, 
    exclude.zeros = exclude.zeros, 
    results.file = file.path(results.dir, "scan1_results_cds_f.RDS"))

cds.f.perm.results.file <- file.path(results.dir, "scan1perm_results_cds_f.RDS")
if(!file.exists(cds.f.perm.results.file)){
    cds.f.perm <- scan1perm(genoprobs = expanded.genoprobs, 
        pheno = mapping.pheno[f.idx,,drop=FALSE], addcovar = covar, 
        n_perm = nperm, cores = 4)
    saveRDS(cds.f.perm, cds.f.perm.results.file)
}else{
    cds.f.perm <- readRDS(cds.f.perm.results.file)
}

cds.m.scans <- map_pheno(expanded.genoprobs, mapping.pheno[m.idx,], exp.K, 
    exclude.zeros = exclude.zeros, 
    results.file = file.path(results.dir, "scan1_results_cds_m.RDS"))

cds.m.perm.results.file <- file.path(results.dir, "scan1perm_results_cds_m.RDS")
if(!file.exists(cds.m.perm.results.file)){
    cds.m.perm <- scan1perm(genoprobs = expanded.genoprobs, 
        pheno = mapping.pheno[m.idx,,drop=FALSE], addcovar = covar, 
        n_perm = nperm, cores = 4)
    saveRDS(cds.m.perm, cds.m.perm.results.file)
}else{
    cds.m.perm <- readRDS(cds.m.perm.results.file)
}

cds.add.scans <- map_pheno(expanded.genoprobs, mapping.pheno, exp.K, 
    exclude.zeros = exclude.zeros, addcovar = covar,
    results.file = file.path(results.dir, "scan1_results_cds_add.RDS"))

cds.add.perm.results.file <- file.path(results.dir, "scan1perm_results_cds_add.RDS")
if(!file.exists(cds.add.perm.results.file)){
    cds.add.perm <- scan1perm(genoprobs = expanded.genoprobs, 
        pheno = mapping.pheno, addcovar = covar,
        n_perm = nperm, cores = 4)
    saveRDS(cds.add.perm, cds.add.perm.results.file)
}else{
    cds.add.perm <- readRDS(cds.add.perm.results.file)
}

cds.int.scans <- map_pheno(expanded.genoprobs, mapping.pheno, exp.K, 
    exclude.zeros = exclude.zeros, addcovar = covar, intcovar = covar,
    results.file = file.path(results.dir, "scan1_results_cds_int.RDS"))

cds.int.perm.results.file <- file.path(results.dir, "scan1perm_results_cds_int.RDS")
if(!file.exists(cds.int.perm.results.file)){
    cds.int.perm <- scan1perm(genoprobs = expanded.genoprobs, 
        pheno = mapping.pheno, addcovar = covar, intcovar = covar,
        n_perm = nperm, cores = 4)
    saveRDS(cds.int.perm, cds.int.perm.results.file)
}else{
    cds.int.perm <- readRDS(cds.int.perm.results.file)
}

```

### CDS QTL for Females {.tabset .tabset-fade .tabset-pills}

```{r f_cds, fig.width = 10, fig.height = 4, results = "asis"}

#pdf("~/Desktop/CDS_Female.pdf", width = 10, height = 12);par(mfrow = c(3,1))
plot_pval_fun(scan.results = cds.f.scans, perm.results = cds.f.perm, tab.level = "####")
#dev.off()
```


### CDS QTL for Males {.tabset .tabset-fade .tabset-pills}

```{r m_cds, fig.width = 10, fig.height = 4, results = "asis"}
#pdf("~/Desktop/CDS_Male.pdf", width = 10, height = 12);par(mfrow = c(3,1))
plot_pval_fun(scan.results = cds.m.scans, perm.results = cds.m.perm, tab.level = "####")
#dev.off()
```


### CDS QTL for Both Sexes Overlayed {.tabset .tabset-fade .tabset-pills}

```{r cds_overlayed, fig.width = 10, fig.height = 10, results = "asis"}
#pdf("~/Desktop/CDS_Sex_Overlayed.pdf", width = 12, height = 12)
layout.mat <- matrix(c(1:6), ncol = 2, byrow = TRUE)
layout(layout.mat, widths = c(1, 0.3))
sex.cols = c("Female" = "#377eb8", "Male" = "#4daf4a")
for(i in 1:length(cds.f.scans)){
    par(mar = c(4,4,4,4))

    sig.level.f <- summary(cds.f.perm, alpha = alpha)[,i]
    sig.level.m <- summary(cds.m.perm, alpha = alpha)[,i]
    ymax <- max(c(sig.level.f, sig.level.m, cds.f.scans[[i]]))*1.1
    plot(cds.f.scans[[i]], map = map, ylim = c(0,ymax), col = sex.cols["Female"],
        main = names(cds.f.scans)[i])
    plot(cds.m.scans[[i]], map = map, add = TRUE, col = sex.cols["Male"])
    plot.dim <- par("usr")
    segments(x0 = plot.dim[1], x1 = plot.dim[2], y0 = sig.level.f, lty = c(1,2),
        col = sex.cols["Female"])
    segments(x0 = plot.dim[1], x1 = plot.dim[2], y0 = sig.level.m, lty = c(1,2),
        col = sex.cols["Male"])
    par(xpd = NA)
    text(x = rep(plot.dim[2]*1.005, 2), y = sig.level.f, labels = alpha, adj = 0, cex = 0.7)
    text(x = rep(plot.dim[2]*1.005, 2), y = sig.level.m, labels = alpha, adj = 0, cex = 0.7)

    par(mar = c(0,0,4,2))
    plot.new()
    plot.window(xlim = c(0,1), ylim = c(0,1))
    legend(0, 0.9, lty = 1, col = sex.cols, legend = names(sex.cols), lwd = 3)
}
#dev.off()
```


### CDS QTL for Interaction Overlayed

```{r int_cds, fig.width = 8, fig.height = 10}

#pdf("~/Desktop/CDS_Interaction_overlayed.pdf", width = 12, height = 12)
layout(matrix(c(1:6), ncol = 2, byrow = TRUE), widths = c(1, 0.3))
for(i in 1:length(cds.int.scans)){
    par(mar = c(4,4,4,0))
    sig.level.int <- summary(cds.int.perm, alpha = alpha)[,i]
    sig.level.add <- summary(cds.add.perm, alpha = alpha)[,i]
    ymax <- max(c(sig.level.int, sig.level.add, cds.int.scans[[i]], cds.add.scans[[i]]))*1.1
    plot(cds.int.scans[[i]], map = map, ylim = c(0, ymax), main = names(cds.int.scans)[i], 
        col = "#d95f02")
    plot(cds.add.scans[[i]], map = map, add = TRUE, col = "#463D86")
    abline(h = sig.level.int, lty = c(1,2), col = "#d95f02")
    abline(h = sig.level.add, lty = c(1,2), col = "#463D86")
    par(mar = c(4,0,4,4))
    plot.new()
    plot.window(xlim = c(0,1), ylim = c(0,1))
    legend(0, 0.9, lty = 1, col = c("#d95f02", "#463D86"), 
        legend = c("Interactive", "Additive"), lwd = 3)
}
#dev.off()
```

### CDS QTL Interaction-Additive

```{r cds_int_add, fig.width = 10, fig.height = 10}
#pdf("~/Desktop/CDS_Interaction-Additive.pdf", width = 10, height = 12)
par(mfrow = c(3,1))
for(i in 1:length(cds.int.scans)){
    sig.level.int <- summary(cds.int.perm-cds.add.perm, alpha = alpha)[,i]
    ymax <- max(c(sig.level.int, cds.int.scans[[i]]-cds.add.scans[[i]]))*1.1
    plot(cds.int.scans[[i]]-cds.add.scans[[i]], map = map, ylim = c(0, ymax),
        main = names(cds.int.scans)[i])
    abline(h = sig.level.int, lty = c(1,2))
}
#dev.off()
```

### CDS by individual LOD traces {.tabset .tabset-fade .tabset-pills}

```{r plot_cds_scans, fig.width = 10, fig.height = 4, warning = FALSE, results = "asis"}
#plot the scans, and FDR results
if(run_permutations){
    #pdf("~/Desktop/test.pdf")
    fdr_summaries_cds <- plot_fdr_fun(scan.results = cds.scans, perm.results = cds.perm, 
        tab.level = "####", maxy = NULL)
    #sig_summaries_cds <- plot_pval_fun(scan.results = cds.scans, perm.results = cds.perm, tab.level = "####")
    #dev.off()
}else{
    for(i in 1:length(cds.scans)){
        cat("####", names(cds.scans)[i], "\n")
        plot(cds.scans[[i]], map = map)
        cat("\n\n")
    }
}
```

### CDS by individual allele effects {.tabset .tabset-fade .tabset-pills}

The following plot shows the allele effects for the Chr 14
QTL for Global CDS. The full chromosome has a lot of allele 
frequency weirdness on it. There are two plots below. One 
of the full chromosome, and another that captures as much 
of the QTL as possible without showing the weirdness.

```{r global_detail, fig.height = 8, fig.width = 8}

#round genotypes to squash out the wild associations we 
#get with teeny tiny probabilities
rounded.geno <- expanded.genoprobs
for(i in 1:length(rounded.geno)){
    rounded.geno[[i]] <- round(rounded.geno[[i]], 2)
}

chr = 14
global.lod <- scan1(rounded.geno[,chr], mapping.pheno[,"Global"], exp.K[[chr]],
    addcovar = covar)
global.coef <- scan1coef(rounded.geno[,chr], mapping.pheno[,"Global"], exp.K[[chr]],
    addcovar = covar)

plot_coefCC(global.coef, map = map, scan1_output = global.lod,
    ylim = c(-2, 2), col = strain.colors, main = "Global CDS full Chr 14",
    top_panel_prop = 0.5)


plot_coefCC(global.coef, map = map, scan1_output = global.lod,
    ylim = c(-2, 2), col = strain.colors, xlim = c(95, 125),
    main = "Global CDS Chr 14 QTL Window", top_panel_prop = 0.5)


```

```{r scan_coef, fig.width = 7, fig.height = 7, results = "asis", eval = FALSE}
cds.coef <- allele_coef(map.geno = expanded.genoprobs, 
    map.pheno = mapping.pheno, map.k = exp.K, addcovar = mapping.covar,
    scan.results = cds.scans,
    lod.threshold = allele.thresh, exclude.zeros = exclude.zeros, 
    chr.lod.file = file.path(results.dir, "Chr.LOD.cds.RDS"), 
    chr.coef.file = file.path(results.dir, "Chr.Coef.cds.RDS"))

#pdf("~/Desktop/test.pdf", width = 7, height = 7)
if(run_permutations){
    plot_coef_scans(coef.results = cds.coef, 
        map.geno = expanded.genoprobs, map.pheno = mapping.pheno, 
        fdr_results = fdr_summaries_cds, tab.level = "####",
        sig_lines = "Genome-wide")
}else{
    plot_coef_scans(coef.results = cds.coef, 
        map.geno = expanded.genoprobs, map.pheno = mapping.pheno, 
        fdr_results = NULL, tab.level = "####",
        sig_lines = "Genome-wide")
}

#dev.off()
```

### LOD intervals {.tabset .tabset-fade .tabset-pills} 

The following tables show LOD peak intervals for the top 3 peaks from 
each trait.


```{r lod_peaks, results = "asis"}
top.n <- 3
for(ph in 1:length(cds.scans)){
    cat("####", names(cds.scans)[ph], "\n")
    peak.table <- find_peaks(cds.scans[[ph]], map = map, prob = 0.95)
    lod.order <- order(peak.table[,"lod"], decreasing = TRUE)
    top.peaks <- peak.table[lod.order[1:top.n],3:ncol(peak.table)]
    rownames(top.peaks) <- NULL
    print(kable(top.peaks))
    cat("Thresholds:\n")
    print(kable(fdr_summaries_cds[ph,,drop=FALSE]))
    cat("\n\n")
}
```


## Incidence {.tabset .tabset-fade .tabset-pills}

Emily calculated an incidence level for each strain as a whole
and separately by sex. Incidence values by strain are as follows.

```{r incidence, fig.width = 5, fig.height = 7, results = "asis"}

for(i in 1:length(incidence)){
    cat("###", names(incidence)[i], "\n")
    imageWithText(incidence[[i]], main = names(incidence)[i], use.pheatmap.colors = TRUE)
    cat("\n\n")
}
```

```{r check_diffs, eval = FALSE}

par(mfrow = c(3,4))
for(i in 1:ncol(incidence[[1]])){
    xlim <- c(0, max(incidence[[1]][,1])*1.1)
    ylim <- c(0, max(incidence[[2]][,1])*1.1)
    plot(jitter(incidence[[1]][,i], factor = 2), 
        jitter(incidence[[2]][,i], factor = 2), 
        main = colnames(incidence[[1]])[i],
        xlab = "Female Value", ylab = "Male Value", xlim = xlim, ylim = ylim)
    abline(0,1)
}

```

## Map Incidence

We also want to map incidence at the strain level.
There are three incidence matrices. One has the incidence
for each strain overall. The other two are split by sex.

We mapped the overall incidence per strain on its own.
Then we combined the incidence matrices split by sex 
so we could use sex as an additive and interactive 
covariate as we did with CDS.

```{r calc_avg_pheno}
#calculate average phenotypes and construct new
#genoprobs and kinship for the mean values.
genoprob.strain <- sapply(strsplit(rownames(mapping.genoprobs[[1]]), "/", fixed = TRUE), function(x) x[1])
strain.by.sex <- cbind(rep(genoprob.strain, each = 2), rep(c("F", "M"), length(genoprob.strain)))
ind.labels <- apply(strain.by.sex, 1, function(x) paste(x, collapse = "_"))
mean.genoprobs <- mapping.genoprobs
mean.K <- mapping.K
for(i in 1:length(mean.genoprobs)){
    strain.idx <- match(strain.by.sex[,1], genoprob.strain)
    mean.genoprobs[[i]] <- mapping.genoprobs[[i]][strain.idx,,]
    rownames(mean.genoprobs[[i]]) <- ind.labels
    mean.K[[i]] <- mapping.K[[i]][strain.idx, strain.idx]
    rownames(mean.K[[i]]) <- colnames(mean.K[[i]]) <- ind.labels
}

mean.pheno <- t(apply(strain.by.sex, 1, 
    function(x) colMeans(mapping.pheno[intersect(which(mapping.factors[,1] == x[1]), 
    which(mapping.factors[,2] == x[2])),], na.rm = TRUE)))
rownames(mean.pheno) <- ind.labels

mean.covar <- matrix(as.numeric(as.factor(strain.by.sex[,2])), ncol = 1)
rownames(mean.covar) <- ind.labels

#mean.pheno <- mean.pheno.old[which(!is.na(rowSums(mean.pheno.old))),]
#norm.mean.pheno <- apply(mean.pheno.old, 2, rankZ)
norm.mean.pheno <- mean.pheno
```

```{r avg_geno_k}
#make genoprobs object and a kinship object for 
#the combined incidence matrix

strain.genoprobs <- mean.genoprobs
strain.K <- mean.K

just.strain <- sapply(strsplit(rownames(mean.genoprobs[[1]]), "_"), function(x) x[1])
all.cc.strains <- unique(just.strain)
strain.idx <- match(mapping.strains, just.strain)
strain.idx <- strain.idx[which(!is.na(strain.idx))]

for(i in 1:length(mean.genoprobs)){
    strain.genoprobs[[i]] <- mean.genoprobs[[i]][strain.idx,,]
    rownames(strain.genoprobs[[i]]) <- mapping.strains
    strain.K[[i]] <- mean.K[[i]][strain.idx, strain.idx]
    rownames(strain.K[[i]]) <- colnames(strain.K[[i]]) <- mapping.strains
}

```

Make an overall incidence per strain matrix
and another that has both sexes in it so we 
can play the additive/interactive game again.

We rank Z normalized the columns of each matrix
before mapping.

```{r make_mats}

incidence.strains <- rownames(incidence$incidence_strain)
incidence.strains <- gsub("/", "", gsub(" ", "", incidence.strains))
overall.inc <- apply(incidence$incidence_strain, 2, rankZ)

inc.by.sex <- rbind(incidence$incidence_female, incidence$incidence_male)
inc.by.sex <- apply(inc.by.sex, 2, rankZ)
rownames(inc.by.sex) <- paste(incidence.strains, 
    c(rep("F", nrow(incidence$incidence_female)), rep("M", nrow(incidence$incidence_male))), 
    sep = "_")
incidence.covar <- matrix(1, ncol = 1, nrow = nrow(inc.by.sex))
incidence.covar[1:nrow(incidence$incidence_female)] <- 0
rownames(incidence.covar) <- rownames(inc.by.sex)
```

```{r mapping_by_sex}
f.idx <- grep("F", rownames(inc.by.sex))
m.idx <- grep("M", rownames(inc.by.sex))
strain.sex.covar <- 1-dummy_covar(matrix(sapply(strsplit(rownames(inc.by.sex), "_"), function(x) x[2]), ncol = 1))
rownames(strain.sex.covar) <- rownames(inc.by.sex)

f.inc.scan <- map_pheno(mean.genoprobs, inc.by.sex[f.idx,], mean.K, 
    exclude.zeros = exclude.zeros, 
    results.file = file.path(results.dir, "Incidence_scan_f.RDS"))
f.inc.perm.file <- file.path(results.dir, "Incidence_perm_scan_f.RDS")
if(!file.exists(f.inc.perm.file)){
    f.inc.perm <- scan1perm(genoprobs = mean.genoprobs, pheno = inc.by.sex[f.idx,], 
        kinship = mean.K, n_perm = nperm)
    saveRDS(f.inc.perm, f.inc.perm.file)
}else{
    f.inc.perm <- readRDS(f.inc.perm.file)
}

m.inc.scan <- map_pheno(mean.genoprobs, inc.by.sex[m.idx,], mean.K, 
    exclude.zeros = exclude.zeros, 
    results.file = file.path(results.dir, "Incidence_scan_m.RDS"))
m.inc.perm.file <- file.path(results.dir, "Incidence_perm_scan_m.RDS")
if(!file.exists(m.inc.perm.file)){
    m.inc.perm <- scan1perm(genoprobs = mean.genoprobs, pheno = inc.by.sex[m.idx,], 
        kinship = mean.K, n_perm = nperm)
    saveRDS(m.inc.perm, m.inc.perm.file)
}else{
    m.inc.perm <- readRDS(m.inc.perm.file)
}


inc.scan.add <- map_pheno(mean.genoprobs, inc.by.sex, mean.K, 
    exclude.zeros = exclude.zeros, addcovar = strain.sex.covar,
    results.file = file.path(results.dir, "Incidence_scan_add.RDS"))
inc.add.perm.file <- file.path(results.dir, "Incidence_perm_scan_add.RDS")
if(!file.exists(inc.add.perm.file)){
    inc.add.perm <- scan1perm(genoprobs = mean.genoprobs, pheno = inc.by.sex, 
        kinship = mean.K, n_perm = nperm, addcovar = strain.sex.covar)
    saveRDS(inc.add.perm, inc.add.perm.file)
}else{
    inc.add.perm <- readRDS(inc.add.perm.file)
}

inc.scan.int <- map_pheno(mean.genoprobs, inc.by.sex, mean.K, 
    exclude.zeros = exclude.zeros, addcovar = strain.sex.covar,
    intcovar = strain.sex.covar, 
    results.file = file.path(results.dir, "Incidence_scan_int.RDS"))
inc.int.perm.file <- file.path(results.dir, "Incidence_perm_scan_int.RDS")
if(!file.exists(inc.int.perm.file)){
    inc.int.perm <- scan1perm(genoprobs = mean.genoprobs, pheno = inc.by.sex, 
        kinship = mean.K, n_perm = nperm, addcovar = strain.sex.covar, 
        intcovar = strain.sex.covar)
    saveRDS(inc.int.perm, inc.int.perm.file)
}else{
    inc.int.perm <- readRDS(inc.int.perm.file)
}
```

### Incidence QTL for Females {.tabset .tabset-fade .tabset-pills}

```{r f_inc, fig.width = 10, fig.height = 4, results = "asis"}

#pdf("~/Desktop/Incidence_Female.pdf", width = 10, height = 12);par(mfrow = c(3,1))
plot_pval_fun(scan.results = f.inc.scan, perm.results = f.inc.perm, tab.level = "####")
#dev.off()
```

### Incidence QTL for Males {.tabset .tabset-fade .tabset-pills}

```{r m_inc, fig.width = 10, fig.height = 4, results = "asis"}

#pdf("~/Desktop/Incidence_Male.pdf", width = 10, height = 12);par(mfrow = c(3,1))
plot_pval_fun(scan.results = m.inc.scan, perm.results = m.inc.perm, tab.level = "####")
#dev.off()
```

### Incidence QTL both sexes overlayed

```{r inc_sex_overlayed, fig.width = 10, fig.height = 10}

#pdf("~/Desktop/Incidence_Sex_Overlayed.pdf", width = 12, height = 12)
layout.mat <- matrix(c(1:6), ncol = 2, byrow = TRUE)
layout(layout.mat, widths = c(1, 0.3))
sex.cols = c("Female" = "#377eb8", "Male" = "#4daf4a")
for(i in 1:length(f.inc.scan)){
    par(mar = c(4,4,4,4))

    sig.level.f <- summary(f.inc.perm, alpha = alpha)[,i]
    sig.level.m <- summary(m.inc.perm, alpha = alpha)[,i]
    ymax <- max(c(sig.level.f, sig.level.m, f.inc.scan[[i]], m.inc.scan[[i]]))*1.1
    plot(f.inc.scan[[i]], map = map, ylim = c(0,ymax), col = sex.cols["Female"], 
        main = names(f.inc.scan)[i])
    plot(m.inc.scan[[i]], map = map, add = TRUE, col = sex.cols["Male"])
    plot.dim <- par("usr")
    segments(x0 = plot.dim[1], x1 = plot.dim[2], y0 = sig.level.f, lty = c(1,2),
        col = sex.cols["Female"])
    segments(x0 = plot.dim[1], x1 = plot.dim[2], y0 = sig.level.m, lty = c(1,2),
        col = sex.cols["Male"])
    par(xpd = NA)
    text(x = rep(plot.dim[2]*1.005, 2), y = sig.level.f, labels = alpha, adj = 0, cex = 0.7)
    text(x = rep(plot.dim[2]*1.005, 2), y = sig.level.m, labels = alpha, adj = 0, cex = 0.7)

    par(mar = c(0,0,4,2))
    plot.new()
    plot.window(xlim = c(0,1), ylim = c(0,1))
    legend(0, 0.9, lty = 1, col = sex.cols, legend = names(sex.cols), lwd = 3)
}
#dev.off()
```

### Incidence QTL for Interaction Overlayed

```{r int_inc, fig.width = 10, fig.height = 10}

#pdf("~/Desktop/Incidence_Interaction_overlayed.pdf", width = 12, height = 12)
layout(matrix(c(1:6), ncol = 2, byrow = TRUE), widths = c(1, 0.3))
for(i in 1:length(inc.scan.add)){
    par(mar = c(4,4,4,0))
    sig.level.int <- summary(inc.int.perm, alpha = alpha)[,i]
    sig.level.add <- summary(inc.add.perm, alpha = alpha)[,i]
    ymax <- max(c(sig.level.int, sig.level.add, inc.scan.int[[i]], inc.scan.add[[i]]))*1.1
    plot(inc.scan.int[[i]], map = map, ylim = c(0, ymax), main = names(inc.scan.int)[i], 
        col = "#d95f02")
    plot(inc.scan.add[[i]], map = map, add = TRUE, col = "#463D86")
    abline(h = sig.level.int, lty = c(1,2), col = "#d95f02")
    abline(h = sig.level.add, lty = c(1,2), col = "#463D86")
    par(mar = c(4,0,4,4))
    plot.new()
    plot.window(xlim = c(0,1), ylim = c(0,1))
    legend(0, 0.9, lty = 1, col = c("#d95f02", "#463D86"), 
        legend = c("Interactive", "Additive"), lwd = 3)
}
#dev.off()
```

### Incidence QTL Interaction-Additive

```{r inc_int_add, fig.width = 10, fig.height = 10}

#pdf("~/Desktop/Incidence_Interaction-Additive.pdf", width = 10, height = 12)
par(mfrow = c(3,1))
for(i in 1:length(inc.scan.int)){
    sig.level.int <- summary(inc.int.perm-inc.add.perm, alpha = alpha)[,i]
    ymax <- max(c(sig.level.int, inc.scan.int[[i]]-inc.scan.add[[i]]))*1.1
    plot(inc.scan.int[[i]]-inc.scan.add[[i]], map = map, ylim = c(0, ymax),
        main = names(inc.scan.int)[i])
    plot.dim <- par("usr")
    segments(x0 = plot.dim[1], x1 = plot.dim[2], y0 = sig.level.int, lty = c(1,2))
}
#dev.off()
```

### Overall Incidence Distributions - Not Normalized

The following plots show the distributions of these traits
across strains before normalizing. 

```{r incidence_dist, fig.height = 3, fig.width = 9}
par(mfrow = c(1,3))
for(i in 1:ncol(incidence$incidence_strain)){
    hist(incidence$incidence_strain[,i], main = colnames(incidence$incidence_strain)[i],
        xlab = "Incidence")
}
strain_K <- calc_kinship(strain.genoprobs, "overall")
#test <- est_herit(incidence$incidence_strain, strain_K)
#par(mar = c(4, 16, 4, 4))
#barplot(as.numeric(test), names = colnames(incidence$incidence_strain), las = 2, horiz = TRUE)
```

### Overall Incidence Distributions - Normalized

The following plots show the distributions of these traits
across strains after normalizing.

```{r norm_incidence_dist, fig.height = 3, fig.width = 9}
par(mfrow = c(1,3))
for(i in 1:ncol(overall.inc)){
    hist(overall.inc[,i], main = colnames(overall.inc)[i],
        xlab = "Incidence")
}
#test <- est_herit(overall.inc, strain_K)
#par(mar = c(4, 16, 4, 4))
#barplot(as.numeric(test), names = colnames(overall.inc), las = 2, horiz = TRUE)
#kin.decomp <- plot.decomp(strain_K)
#kin.pc <- kin.decomp$u[,1,drop=FALSE]
#rownames(kin.pc) <- rownames(strain_K)[kin.decomp$rows.used]
#common.ind <- intersect(rownames(overall.inc), rownames(strain_K))
#plot.with.model(overall.inc[common.ind,1], kin.pc[common.ind,1])
#all.cor <- apply(overall.inc[common.ind,], 2, function(x) cor(x, kin.pc[common.ind,1]))
#barplot(rbind(all.cor, test), las = 2, beside = TRUE)
#abline(h = 0)
```

### Allele effect heatmaps


### Incidence Distributions by Sex - Not Normalized

The following plots show the distributions of these traits
split by sex. Males and females are stacked on top of each 
other, so the distribution represents the overall distribution, 
but they are colored separately.

```{r inc_by_sex_pre_norm, fig.height = 3, fig.width = 9}
pre.norm <- rbind(incidence$incidence_female, incidence$incidence_male)
par(mfrow = c(1,3))
for(i in 1:ncol(pre.norm)){
    hist_with_points(pre.norm[,i], main = colnames(pre.norm)[i],
        xlab = "Incidence", col = incidence.covar[,1]+3)
    legend("topright", col = c(0,1)+3, pch = 16, legend = c("F", "M"))
}

#test <- est_herit(incidence$incidence_female, strain_K)
#par(mar = c(4, 16, 4, 4))
#barplot(as.numeric(test), names = colnames(overall.inc), las = 2, horiz = TRUE)

```

### Incidence Distributions by Sex - Normalized

```{r inc_by_sex_norm, fig.height = 3, fig.width = 9}
par(mfrow = c(1,3))
for(i in 1:ncol(pre.norm)){
    hist_with_points(inc.by.sex[,i], main = colnames(inc.by.sex)[i],
        xlab = "Incidence", col = incidence.covar[,1]+3)
    legend("topright", col = c(0,1)+3, pch = 16, legend = c("F", "M"))
}

```

```{r no_perm}
#set run_permutations to FALSE
#if we are not ready to run permutations on incidence yet
#run_permutations = FALSE
```

```{r map_overall_inc, warning = FALSE}

inc.scan.overall <- map_pheno(strain.genoprobs, overall.inc, strain.K, 
    exclude.zeros = FALSE, 
    results.file = file.path(results.dir, "scan1_results_overall_incidence.RDS"))

if(run_permutations){    
    #incidence.overall.perm <- perm_scans(map.geno = strain.genoprobs, map.pheno = overall.inc, 
    #    map.k = strain.K, scan1.results = inc.scan.overall, groups = NULL, exclude.zeros = FALSE, 
    #    nperm = nperm,
    #    results.file = file.path(results.dir, paste0("scan1perm_results_incidence_overall10.RDS")))   
    
    results.file = file.path(results.dir, paste0("scan1perm_results_incidence_overall.RDS"))

    if(!file.exists(results.file)){
        incidence.perm <- scan1perm(strain.genoprobs, overall.inc, kinship = strain.K, n_perm = nperm)   
        saveRDS(incidence.perm, results.file)
    }else{
        incidence.perm <- readRDS(results.file)
    }
    perm.summ <- summary(incidence.perm, alpha = alpha)
}
```


### LOD traces: Incidence Overall {.tabset .tabset-fade .tabset-pills}

The following plots show the LOD traces for each incidence trait.


```{r plot_inc_perm_overall, warning = FALSE, fig.height = 5, fig.width = 9, results = "asis"}
#pdf("~/Desktop/test.pdf")
if(run_permutations){
    #fdr_summaries_incidence_overall <- plot_fdr_fun(scan.results = inc.scan.overall, 
    #    perm.results = incidence.overall.perm, tab.level = "####")
    for(ph in 1:length(inc.scan.overall)){
        cat("####", names(inc.scan.overall)[ph], "\n")
        ylim <- c(0, max(c(max(inc.scan.overall[[ph]]), max(perm.summ[,ph])))*1.05)
        #ylim <- c(0, 9)
        plot(inc.scan.overall[[ph]], map = map, ylim = ylim)
        abline(h = perm.summ[,ph], lty = 1:length(alpha))
        plot.dim <- par("usr")
        par(xpd = TRUE)
        text(x = plot.dim[2]*1.01, y = perm.summ[,ph], 
            labels = rownames(perm.summ), cex = 0.5, adj = 0)
        par(xpd = FALSE)

        cat("\n\n")
    }
}else{    
    ymax <- max(sapply(inc.scan.overall, function(x) max(x[,1])))*1.05
    for(i in 1:length(inc.scan.overall)){
        cat("####", names(inc.scan.overall)[i], "\n")
        plot(inc.scan.overall[[i]], map = map, main = names(inc.scan.overall)[i], 
            ylim = c(0, ymax))
        cat("\n\n")
    }
}
#dev.off() 
```


### LOD Intervals: Incidence Overall {.tabset .tabset-fade .tabset-pills} 

The following tables show LOD peak intervals for the top 3 peaks from 
each trait.


```{r inc_lod_peaks, results = "asis"}
for(ph in 1:length(inc.scan.overall)){
    cat("####", names(inc.scan.overall)[ph], "\n")
    peak.table <- find_peaks(inc.scan.overall[[ph]], map = map, prob = 0.95)
    lod.order <- order(peak.table[,"lod"], decreasing = TRUE)
    top.peaks <- peak.table[lod.order[1:top.n],3:ncol(peak.table)]
    rownames(top.peaks) <- NULL
    print(kable(top.peaks))
    cat("Thresholds:\n")
    threshholds <- matrix(Inf, nrow = 1, ncol = ncol(fdr_summaries_cds))
    colnames(threshholds) <- colnames(fdr_summaries_cds)
    threshholds[1:length(alpha)] <- signif(perm.summ[,ph], 3)
    print(kable(threshholds))
    cat("\n\n")
}
```

## Comparing Scans

There is a question as to whether the scans of similar traits 
in these conditions are sufficiently similar. EAE and 
Classical incidence are correlated in terms of phenotype, 
so their mapping should be similar. 

The following plot shows a heatmap of the correlations between
the incidence phenotypes.

```{r inc_cor, fig.width = 6, fig.height = 6}
inc.cor <- cor(overall.inc, use = "pairwise.complete.obs", method = "spearman")
trait.order <- hclust(dist(inc.cor))$order
pheatmap(inc.cor[trait.order, trait.order], display_numbers = TRUE, 
    main = "Incidence Trait Correlations", cluster_cols = FALSE, cluster_rows = FALSE)
```

The following heatmap shows the correlation between
the maps of incidence. Compare this to the correlation
between measured traits. The maps are less correlated
than the traits, but the pattern of correlations are
very similar.

```{r map_cor, fig.width = 6, fig.height = 6}
map.mat <- sapply(inc.scan.overall, function(x) x[,1])
map.cor <- cor(map.mat, use = "pairwise.complete.obs", method = "spearman")

pheatmap(map.cor[trait.order, trait.order], 
    display_numbers = TRUE, cluster_rows = FALSE, cluster_cols = FALSE)
```

The following plot shows how the mapping and trait correlations
relate to each other. For the most part they are very similar.
The correlations between trait pairs tend to be higher than 
the correlations between mapping pairs, which is what we 
expect. The diagonal line shows y = x, and the horizontal 
and vertical lines show y = 0, and x = 0 respectively.

For the Classical-AR pairs, however, the correlation between
the maps is much higher than the correlations between the traits.
I'm not sure why that would be.

```{r compare_cor, fig.width = 6, fig.height = 6}
trait.pairs <- pair.matrix(colnames(map.mat))
map.trait.cor <- matrix(NA, nrow = nrow(trait.pairs), ncol = 2)
colnames(map.trait.cor) <- c("Trait Correlation", "Mapping Correlation")
for(i in 1:nrow(trait.pairs)){
    map.trait.cor[i,1] <- inc.cor[trait.pairs[i,1], trait.pairs[i,2]]
    map.trait.cor[i,2] <- map.cor[trait.pairs[i,1], trait.pairs[i,2]]
}
pair.names <- apply(trait.pairs, 1, function(x) paste(x, collapse = "-"))
plot(map.trait.cor, pch = 16, ylim = c(-0.2, 0.8), xlim = c(-0.6, 1))
abline(0,1)
abline(h = 0, v = 0)
text(map.trait.cor[,1], map.trait.cor[,2], labels = pair.names, pos = 4,
    cex = 0.5)

```


The following heatmap shows the correlations between
the all mapping run above, including with sex as an
interactive covariate.. EAE and Classical are clustered 
in the LOD traces.

```{r lod_cor, fig.width = 8, fig.height = 8}

overall.lod.mat <- sapply(inc.scan.overall, function(x) x[,1])
colnames(overall.lod.mat) <- paste0(colnames(overall.lod.mat), "_overall")
pheatmap(cor(overall.lod.mat))
```

## Large QTL Allele Effects {.tabset .tabset-fade .tabset-pills}

There are some larger QTL in the incidence scans. Here we look
at some of the allele effects to get an idea of how robust these
QTL are.

In all heat maps, the animals are sorted from lowest
phenotype value at the top to greatest phenotype value
at the bottom. The alleles are sorted from lowest effect
to highest effect going from left to right

```{r large_qtl_allele_effects}

#plot.with.model(inc.scan.overall$"Classical.only"[,1], inc.scan.overall$"AR.only"[,1],
#    xlab = "Classical Only LOD", ylab = "AR Only LOD")

#look at individual large QTL to see if they look spurious
#specify groups to average effects together, by strain, for 
#example
plot_max_allele_effects <- function(trait.name, plotting.geno, plotting.pheno, 
    plotting.K, map, scan.results, chr = NULL, round.digs = 2, groups = NULL){
    
    scan.trait.idx <- which(names(scan.results) == trait.name)
    pheno.trait.idx <- which(colnames(plotting.pheno) == trait.name)

    #if no chromosome is specified, take the largest overall LOD score
    if(is.null(chr)){
        max.marker <- names(which.max(scan.results[[scan.trait.idx]][,1]))
    }else{
        chr.idx <- which(names(plotting.geno) == chr)
        marker.chr <- dimnames(plotting.geno[[chr.idx]])[[3]]
        max.marker <- names(which.max(scan.results[[scan.trait.idx]][marker.chr,1]))
    }

    #test a random marker
    #max.marker <- sample(rownames(inc.scan.overall[[trait.idx]]), 1)
    marker.pos <- find_markerpos(map, max.marker)
    marker.geno <- round(pull_genoprobpos(plotting.geno, marker = max.marker), 
        round.digs)
    chr.idx <- which(names(map) == marker.pos[,"chr"])
    chr.K <- plotting.K[[chr.idx]]

    if(!is.null(groups)){
        u_groups <- unique(groups)
        new.pheno <- t(sapply(u_groups, function(x) colMeans(plotting.pheno[which(groups == x),,drop=FALSE])))
        plotting.pheno <- new.pheno
        new.geno <- t(sapply(u_groups, function(x) colMeans(marker.geno[which(groups == x),,drop=FALSE])))
        marker.geno <- new.geno
        matched.idx <- match(u_groups, groups)
        new.K <- chr.K[matched.idx, matched.idx]
        rownames(new.K) <- colnames(new.K) <- u_groups
        chr.K <- new.K
    }

    common.strains <- intersect(rownames(plotting.pheno), rownames(marker.geno))
    annot.df <- data.frame(plotting.pheno[common.strains,pheno.trait.idx,drop=FALSE])

    trait.order <- order(annot.df[,1])
    ordered.names <- common.strains[trait.order]

    model <- fit1(marker.geno, plotting.pheno[,pheno.trait.idx,drop=FALSE], 
        kinship = chr.K)
    marker.lod <- model$lod
    #barplot(model$coef)

    strain.effects <- apply(marker.geno[common.strains,], 2, function(x) annot.df[which(x > 0),1])
    strain.order <- order(sapply(strain.effects, function(x) median(x, na.rm = TRUE)))

    imageWithText(marker.geno[ordered.names,strain.order], 
        main = paste(trait.name, "Chr", marker.pos[,"chr"], ":", 
        signif(marker.pos[,"pos"], 2), "Mb"), use.pheatmap.colors = TRUE, 
        show.text = FALSE, col.text.rotation = 0)

    #pheatmap(marker.geno[ordered.names,strain.order], annotation_row = annot.df,
    #    cluster_rows = FALSE, cluster_cols = FALSE, 
    #    main = paste(trait.name, "Chr", marker.pos[,"chr"], ":", 
    #    signif(marker.pos[,"pos"], 2), "Mb"))


    boxplot(strain.effects[strain.order], col = strain.colors[strain.order],
        main = paste(trait.name, "Chr", marker.pos[,"chr"], ":", 
        signif(marker.pos[,"pos"], 2), "Mb\nLOD =", signif(marker.lod, 2)),
        ylab = trait.name)
    segments(x0 = 0, x1 = length(strain.order)+0.8, y0 = 0)

    result <- list("marker.geno" = marker.geno, "trait.vals" = annot.df,
        "strain.effects" = strain.effects[strain.order])
    invisible(result)
}
```

### Global CDS - Individuals

The matrix is too large to show the individual labels.
To see labels for individual mice, see the file called
Global_CDS_Allele_Effects.png in the results folder. The
order is the same as shown in the boxplot.

```{r global_cds_allele_effects, fig.height = 10, fig.width = 5}

strain.groups = sapply(strsplit(rownames(mapping.genoprobs[[1]])[expanded.idx], "/", 
    fixed = TRUE), function(x) x[1])

layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.5))
test <- plot_max_allele_effects("Global", plotting.geno = expanded.genoprobs, 
    plotting.pheno = mapping.pheno, plotting.K = exp.K, map = map, 
    scan.results = cds.scans, groups = strain.groups)

png(file.path(results.dir, "Global_CDS_Allele_Effects.png"), height = 40, 
    width = 5, units = "in", res = 300)
layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.07))
par(mar = c(4,8,4,4))
plot_max_allele_effects("Global", plotting.geno = expanded.genoprobs, 
    plotting.pheno = mapping.pheno, plotting.K = exp.K, map = map, 
    scan.results = cds.scans)

plot_max_allele_effects("Global", plotting.geno = expanded.genoprobs, 
    plotting.pheno = mapping.pheno, plotting.K = exp.K, map = map, 
    scan.results = cds.scans)

dev.off()
```

### Incidence - EAE Chr 4

```{r eae_allele_effects_4, fig.height = 10, fig.width = 5}
#png("~/Desktop/test.png", height = 10, width = 5, units = "in", res = 300)
layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.5))
test <- plot_max_allele_effects("EAE", plotting.geno = strain.genoprobs, 
    plotting.pheno = overall.inc, plotting.K = strain.K, map = map, 
    scan.results = inc.scan.overall)
#dev.off() 
```

### Incidence - EAE Chr 14

```{r eae_allele_effects_14, fig.height = 10, fig.width = 5}
layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.5))
test <- plot_max_allele_effects("EAE", plotting.geno = strain.genoprobs, 
    plotting.pheno = overall.inc, plotting.K = strain.K, map = map, 
    scan.results = inc.scan.overall, chr = 14)
```


### Incidence - AR Major subtype

```{r ar_allele_effects, fig.height = 10, fig.width = 5}
layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.5))
test <- plot_max_allele_effects("AR.Major.Subtype", plotting.geno = strain.genoprobs, 
    plotting.pheno = overall.inc, plotting.K = strain.K, map = map, 
    scan.results = inc.scan.overall)
```

### Incidence - Remitting

```{r remitting_allele_effects, fig.height = 10, fig.width = 5}
layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.5))
test <- plot_max_allele_effects("Remitting.EAE", plotting.geno = strain.genoprobs, 
    plotting.pheno = overall.inc, plotting.K = strain.K, map = map, 
    scan.results = inc.scan.overall)
```


### Incidence - Classical Only

```{r classical_allele_effects, fig.height = 10, fig.width = 5}
layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.5))
test <- plot_max_allele_effects("Subtype..Classical.only", plotting.geno = strain.genoprobs, 
    plotting.pheno = overall.inc, plotting.K = strain.K, map = map, 
    scan.results = inc.scan.overall)
```


### Incidence - Relapsing Remitting Chr 18

```{r relapsing_remitting_allele_effects_18, fig.height = 10, fig.width = 5}
layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.5))
test <- plot_max_allele_effects("Relapsing.Remitting", plotting.geno = strain.genoprobs, 
    plotting.pheno = overall.inc, plotting.K = strain.K, map = map, 
    scan.results = inc.scan.overall)
```

### Incidence - Relapsing Remitting Chr 5

```{r relapsing_remitting_allele_effects_5, fig.height = 10, fig.width = 5}
layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.5))
test <- plot_max_allele_effects("Relapsing.Remitting", plotting.geno = strain.genoprobs, 
    plotting.pheno = overall.inc, plotting.K = strain.K, map = map, 
    scan.results = inc.scan.overall, chr = 5)
```

## Classic Allele Effect Plots {.tabset .tabset-fade .tabset-pills}

The plots below show the classic allele effect plot for
the QTLs above. If there are allele frequcney issues,
we try to cut those out.

```{r inc_allele, fig.width = 8, fig.height = 8}
#round genotypes to squash out the wild associations we 
#get with teeny tiny probabilities
rounded.geno <- strain.genoprobs
for(i in 1:length(rounded.geno)){
    rounded.geno[[i]] <- round(rounded.geno[[i]], 2)
}

rounded.expanded <- expanded.genoprobs
for(i in 1:length(rounded.geno)){
    rounded.expanded[[i]] <- round(rounded.expanded[[i]], 2)
}

```

### Global CDS - Individual Chr 14

```{r allele_effects_global_14, fig.width = 8, fig.height = 8}
chr <- 14
trait <- "Global"

lod.scan <- scan1(rounded.expanded[,chr], mapping.pheno[,trait], exp.K[[chr]])
coef.scan <- scan1coef(rounded.expanded[,chr], mapping.pheno[,trait], exp.K[[chr]])
plot_coefCC(coef.scan, map = map, scan1_output = lod.scan,
    ylim = c(-2, 2), col = strain.colors, top_panel_prop = 0.5, 
    main = paste(trait, "Chr", chr))
```

### Incidence - EAE Chr 4

```{r allele_effects_inc_eae_4, fig.width = 8, fig.height = 8}
chr <- 4
trait <- "EAE"

lod.scan <- scan1(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
coef.scan <- scan1coef(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
plot_coefCC(coef.scan, map = map, scan1_output = lod.scan,
    ylim = c(-2, 2), col = strain.colors, top_panel_prop = 0.5, 
    main = paste(trait, "Chr", chr))
```

### Incidence - EAE Chr 14

```{r allele_effects_inc_eae_14, fig.width = 8, fig.height = 8}
chr <- 14
trait <- "EAE"

lod.scan <- scan1(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
coef.scan <- scan1coef(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
plot_coefCC(coef.scan, map = map, scan1_output = lod.scan,
    ylim = c(-2, 2), col = strain.colors, top_panel_prop = 0.5, 
    main = paste(trait, "Chr", chr))
```

### Incidence - AR Major Subtype Chr 9

```{r allele_effects_inc_AR_9, fig.width = 8, fig.height = 8}
chr <- 9
trait <- "AR.Major.Subtype"

lod.scan <- scan1(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
coef.scan <- scan1coef(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
plot_coefCC(coef.scan, map = map, scan1_output = lod.scan,
    ylim = c(-2, 2), col = strain.colors, top_panel_prop = 0.5, 
    main = paste(trait, "Chr", chr), xlim = c(0, 30))
```

### Incidence - Remitting Chr 6

```{r allele_effects_inc_remitting_6, fig.width = 8, fig.height = 8}
chr <- 6
trait <- "Remitting.EAE"

lod.scan <- scan1(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
coef.scan <- scan1coef(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
plot_coefCC(coef.scan, map = map, scan1_output = lod.scan,
    ylim = c(-2, 2), col = strain.colors, top_panel_prop = 0.5, 
    main = paste(trait, "Chr", chr))
```

### Incidence - Classical Only Chr 5

```{r allele_effects_inc_classical_5, fig.width = 8, fig.height = 8}
chr <- 5
trait <- "Subtype..Classical.only"

lod.scan <- scan1(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
coef.scan <- scan1coef(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
plot_coefCC(coef.scan, map = map, scan1_output = lod.scan,
    ylim = c(-2, 2), col = strain.colors, top_panel_prop = 0.5, 
    main = paste(trait, "Chr", chr))
```

### Incidence - Relapsing Remitting Chr 18

```{r allele_effects_inc_rr_18, fig.width = 8, fig.height = 8}
chr <- 18
trait <- "Relapsing.Remitting"

lod.scan <- scan1(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
coef.scan <- scan1coef(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
plot_coefCC(coef.scan, map = map, scan1_output = lod.scan,
    ylim = c(-2, 2), col = strain.colors, top_panel_prop = 0.5, 
    main = paste(trait, "Chr", chr))
```

### Incidence - Relapsing Remitting Chr 5

```{r allele_effects_inc_rr_5, fig.width = 8, fig.height = 8}
chr <- 5
trait <- "Relapsing.Remitting"

lod.scan <- scan1(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
coef.scan <- scan1coef(rounded.geno[,chr], overall.inc[,trait], strain.K[[chr]])
plot_coefCC(coef.scan, map = map, scan1_output = lod.scan,
    ylim = c(-2, 2), col = strain.colors, top_panel_prop = 0.5, 
    main = paste(trait, "Chr", chr))
```

