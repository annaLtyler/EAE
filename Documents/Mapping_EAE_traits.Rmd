---
title: "EAE"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
bibliography: eae.bib
---

## Introduction
The purpose of this workflow is to start getting into data 
sent by Dimitry Krementsov and his graduate studen Emily Holt 
at UVM.

They are interested in the genetics of multiple sclerosis (MS).
The mouse model of MS is called [experimental autoimmune 
enchephalomyelitis (EAE)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3229753/).
In this model, mice are injected with CNS antigens which cause
development of autoimmunity. 

The Krementsov lab is inducing EAE in a panel of CC mice 
to investigate the effect of genetic backgroud on this model.
So far they have identified multiple types of EAE that mirror
the human experience better than the standard model. Whereas
the classic mouse model displays a progressive form of ascending
paralysis, the diverse model has relapsing remitting patterns
of disease, as well as axial-rotory (AR) EAE. These patterns are
also seen in humans, but the genetics of the heterogeneity of 
MS in humans has not been well studied.

In this study, we will try to map genetic variants that 
are associated with subtypes of EAE. We will also use TRiAGE
to prioritize genes within the mapped loci.

## Collecting and Processing Data

From the Excel file that Emily sent, I saved the CDS_Individuals
tab as a csv file. I deleted the header material and an empty row.
I also converted all strings "C57BL/6" to "C57BL6" to match the 
other B6 labels.

I also copied the Incidence tab to three files and deleted the 
line without entries. The files are:

* incidence_female.txt - incidence calculations for all females of each strain
* incidence_male.txt - incidence calculations for all males of each strain
* incidence_strain.txt - incidence calculations for each strain including both sexes

```{r get_arguments}
args <- commandArgs(trailingOnly=T)

b6_correction <- as.logical(args[1]) #Use B6 score to do batch correction
batch_as_covar <- as.logical(args[2]) #use batch as a covariate
rank_norm <- as.logical(args[3]) #whether to rank Z normalize adjusted scores.

#b6_correction <- FALSE
#batch_as_covar <- TRUE
#rank_norm <- TRUE


if(is.na(b6_correction) || length(b6_correction) == 0){
b6_correction = FALSE; batch_as_covar = FALSE; rank_norm = FALSE
}

if(b6_correction && batch_as_covar){stop("Set either b6_correction or batch_as_covar to TRUE, not both.")}
```

```{r load_code}
library(here)

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}

overwrite_previous <- FALSE
add_founder_genotypes <- FALSE
remove_strains <- NULL
#remove_strains <- c("CC051", "CC059") #closely related
#remove_strains <- c("CC051") #pick one of them to keep
run_permutations <- TRUE

cc.color.scheme = "original"
#cc.color.scheme = "new"

exclude.zeros = FALSE #if true, we exclude animals with a CDS of 0
disease.thresh = 0 #maximum disease score considered disease-free

cds.file.date = "April_2023" #date for CDS csv file to use in format month_year
inc.file.date = "April_2023" #date for incidence csv files to use in format month_year

nperm = 100
```

## Parameters

```{r param_text}
if(add_founder_genotypes){
    founders.included = "yes"
}else{
    founders.included = "no"
}

if(length(remove_strains) > 0){
    strains.removed <- paste(remove_strains, collapse = ", ")
}else{
    strains.removed = "none"
}

if(!exclude.zeros){
    zero.text <- "Zeros are included in CDS"
    zero.treatment <- "included with"
}else{
    zero.text <- paste("Animals with scores of", disease.thresh, "and below are excluded from CDS.")
    zero.treatment <- "excluded from"
}

if(b6_correction){
    correction.text <- "Batch corrections were made using B6 CDS."
    correction.label <- "B6-batch"
}
if(batch_as_covar){
    correction.text <- "Batch corrections were done using batch as a covariate."
    correction.label <- "covar-batch"
}
if(!b6_correction && !batch_as_covar){
    correction.text <- "No batch corrections were done."
    correction.label <- "no-batch"
}

if(rank_norm){
    norm.text <- "Rank Z normalization was performed."
    norm.label <- "rank-norm"
}else{
    norm.text <- "Rank Z normalization was not performed."
    norm.label <- "no-norm"
}

file.label <- paste(correction.label, norm.label, sep = "_")
```

The parameters for this run are as follows:

* Founders included: `r founders.included`

* CC Strains removed: `r strains.removed`

* Treatment of zeros: `r zero.text`

* Batch correction: `r correction.text`

* Normalization: `r norm.text`

```{r results_dir}
results.dir <- here("Results", paste("Zeros", strsplit(zero.treatment, " ")[[1]][1], file.label, sep = "_"))
if(!file.exists(results.dir)){dir.create(results.dir)}
```

```{r load_libraries, warning = FALSE}
all.packages <- c("pheatmap", "qtl2", "ggplot2", "abind", "igraph", "knitr", "parallel")
load_libraries(all.packages)
cores = detectCores()-1
```

Read in phenotype data.

```{r load_data}
if(cc.color.scheme == "original"){
    strain.colors <- CCorigcolors
}else{
    strain.colors <- CCcolors
}

cds <- read.csv(here("Data", paste0("CDS_", cds.file.date, ".csv")), strip.white = TRUE)
incidence.files <- get.files(path = here("Data"), want = c(inc.file.date, "incidence"), 
    full.names = TRUE)
incidence <- lapply(incidence.files, function(x) as.matrix(read.delim(x, row.names = 1)))
names(incidence) <- gsub(".txt", "", basename(incidence.files))
```

This run uses the CDS file from `r gsub("_", " ", cds.file.date)`.

And the incidence files from `r gsub("_", " ", inc.file.date)`.

```{r batches}
num.cds <- as.matrix(cds[,c("Classical.CDS", "AR.CDS", "Global.CDS")])
rownames(num.cds) <- cds[,"ID"]
#set all scores equal to or lower than the disease threshold
#to zero
if(exclude.zeros){
    num.cds[which(num.cds <= disease.thresh)] <- 0
}

factor.cds <- as.matrix(cds[,c("Strain", "Sex")])
u_batch <- unique(cds[,"EXP"])

#remove animals in batch 170 - these were validation, not part of the original experiment
to.remove = "X170" 
keep.batch <- which(u_batch != "X170")
u_batch <- u_batch[keep.batch]

keep.idx <- which(cds[,"EXP"] != "X170")
cds <- cds[keep.idx,]
num.cds <- num.cds[keep.idx,]
factor.cds <- factor.cds[keep.idx,]

batch.mat <- matrix(0, nrow = nrow(cds), ncol = length(u_batch))
colnames(batch.mat) <- u_batch
for(b in 1:ncol(batch.mat)){
    batch.mat[which(cds[,"EXP"] == u_batch[b]),b] <- 1
}
cds.covar <- as.matrix(cbind(batch.mat, cds[,"Age.at.D0",drop=FALSE]))

pheno.strains <- cds[,"Strain"]
eae.strains <- unique(pheno.strains)
```

## Samples by strain

The following heatmap shows how many individuals are in 
each strain by sex combination.

```{r sample_counts, fig.width = 8, fig.height = 1.5}
count.table <- table(cds[,c("Sex", "Strain")])
strain.order <- c(3:ncol(count.table), 1,2)
par(mar = c(1,4,4,2))
imageWithText(count.table[,strain.order], use.pheatmap.colors = TRUE, 
    col.text.shift = -1.4, row.text.shift = -2, col.text.adj = 0,
    col.text.cex = 0.7, cex = 0.8, row.text.adj = 0.5)
```

## CDS Distribution {.tabset .tabset-fade .tabset-pills}

Each day of the study, each mouse is given a disease CDS 
score between 0 and 5, with lower numbers indicating less 
disease. The cumulative disease score (CDS) for a given mouse
is the sum of these scores over the course of the study.

The distributions of three scores are shown below. Classical
is the classical presentation of paralysis used in the field.
AR (axial rotary) scores an alternate form of paralysis.
Global is the sum of the Classical and AR scores and gives
an overall score of disease regardless of type. 

```{r zeros, fig.width = 8, fig.height = 8}
par(mfrow = c(2,2))
for(i in 1:ncol(num.cds)){
    hist(num.cds[,i], breaks = 50, main = colnames(num.cds)[i], 
    xlab = colnames(num.cds)[i])
}
```

There are many mice that never display measurable symptoms
and have cumulative disease scores of 0. This kind of floor
effect causes problems with statistical tests that assume
a normal distribution.

If exclude.zeros is set to TRUE, these 0 values will be
excluded from CDS mapping.

In this analysis `r zero.text`.

The plots below show the CDS distribution by strain.

```{r cds, results = "asis", fig.width = 10, fig.height = 5}

plot_cds_by_strain <- function(scores, strain.labels, exclude.zeros = TRUE,
    ymin = NULL, ymax = NULL, plot.label = ""){
    
    u_strain <- unique(strain.labels)
    strain.idx <- lapply(u_strain, function(x) which(strain.labels == x))

    if(exclude.zeros){
        nonzero.idx <- which(scores != 0)
    }else{
        nonzero.idx <- 1:length(scores)
    }
    strain.cds <- lapply(strain.idx, function(x) scores[intersect(nonzero.idx, x)])
    names(strain.cds) <- u_strain
    strain.order <- order(sapply(strain.cds, mean))

    if(is.null(ymax)){ymax = max(scores, na.rm = TRUE)}
    if(is.null(ymin)){
        ymin = min(scores, na.rm = TRUE)
        #if(ymin > 0){ymin <- 0}
    }

    #quartz(width = 10, height = 5)
    layout(matrix(c(1,2), ncol = 2), width = c(1, 0.5))
    par(mar = c(4,4,4,0))
    stripchart(strain.cds[strain.order], vertical = TRUE, pch = 16, 
        col = "gray", method = "jitter", las = 2, ylim = c(ymin, ymax),
        main = paste(plot.label, "cds"), ylab = "CDS")
    a <- hist(unlist(strain.cds), plot = FALSE)
    par(mar = c(4,0,4,2))
    plot.new()
    plot.window(xlim = c(0, max(a$counts)), ylim = c(ymin, ymax))
    segments(x0 = rep(0, length(a$counts)), x1 = a$counts, y0 = a$mids, 
        lwd = 10, col = "gray")
    #text(x = a$counts+2, y = a$mids, labels = a$counts, adj = 0, cex = 0.7)
    mtext("Individual Counts", side = 3)
    axis(1)

    invisible(strain.cds)
}

for(cd in 1:ncol(num.cds)){
    cat("###", colnames(num.cds)[cd], "\n")
    temp.vals <- plot_cds_by_strain(scores = num.cds[,cd], 
        strain.labels = factor.cds[,"Strain"], exclude.zeros = exclude.zeros,
        ymax = max(num.cds), plot.label = colnames(num.cds)[cd])
    cat("\n\n")
}
```

## Batch Effects

The individuals were run in multiple batches, which can 
cause systematic biases in the data. We need to correct
any batch effects that we find before we map.

The following heatmap shows how the different 
strains and sexes were represented in different 
batches. The males and females are shown separately.

```{r batch_assortment, fig.width = 5, fig.height = 7}
batch.list <- vector(mode = "list", length = length(u_batch))
for(b in 1:length(u_batch)){
    batch.idx <- which(cds.covar[,b] == 1)
    batch.mat <- matrix(0, nrow = length(eae.strains), ncol = 2)
    rownames(batch.mat) <- eae.strains
    batch.table <- table(data.frame(factor.cds[batch.idx,]))
    batch.mat[match(rownames(batch.table), eae.strains),] <- batch.table
    colnames(batch.mat) <- paste(colnames(cds.covar)[b], colnames(batch.table), sep = "_")
    batch.list[[b]] <- batch.mat
}
all.batch.counts <- Reduce("cbind", batch.list)
imageWithText(all.batch.counts, use.pheatmap.colors = TRUE, col.text.shift = -38.5,
col.text.rotation = 45, col.text.adj = 0, cex = 0.7)
```

The following boxplots show the batch values for the B6 
animals. These show that the batches had an increase in 
CDS across the batches.

```{r b6_batch, fig.width = 8, fig.height = 8}
b6.idx <- which(factor.cds[,1] == "C57BL6")
if(exclude.zeros){
    nonzero.idx <- lapply(1:ncol(num.cds), function(x) which(num.cds[,x] != 0))
}else{
    nonzero.idx <- lapply(1:ncol(num.cds), function(x) 1:nrow(num.cds))
}
b6.batch.idx <- apply(cds.covar[,1:(ncol(cds.covar)-1)], 2, 
    function(x) intersect(which(x == 1), b6.idx))

par(mfrow = c(2,2))
b6.by.batch <- vector(mode = "list", length = ncol(num.cds))
names(b6.by.batch) <- colnames(num.cds)
for(cd in 1:ncol(num.cds)){
    #get batch values for this CDS
    vals.by.batch <- lapply(1:length(b6.batch.idx), 
        function(x) num.cds[intersect(b6.batch.idx[[x]], nonzero.idx[[cd]]),cd])
    names(vals.by.batch) <- u_batch
    b6.by.batch[[cd]] <- vals.by.batch
    boxplot(b6.by.batch[[cd]], main = colnames(num.cds)[cd])    
}

```


### Batch correction procedure

The B6 batch correction procedure is as follows:

1. Calculate the overall mean CDS for B6 mice 
    across the entire experiment
2. Calculate the mean CDS B6 mice in each batch.
3. Adjust all mice in each batch based on the
    difference in means in the B6. Subtract off 
    the mean deviation, and divide by the standard
    deviation.
4. Male and female B6 mice do not have a sex 
    difference in CDS, and adjusting by the 
    two sexes separately could inadvertently 
    introduce a sex effect into the other strains,
    so we use overall means rather than sex-specific 
    means.

The batch correction procedure using batch as a covariate is as follows:

1. Create a binary matrix indicating whether each individual
    was run in each batch (1) or not (0).
2. Regress this matrix out of the CDS matrix.


### Remove batch effects {.tabset .tabset-fade .tabset-pills}

```{r adj_cds}
#only correct Classical and Global
#change these indices to change which
#traits are adjusted for batch effects
cds.idx <- c(1,2,3) 
```

Adjust for batch. We adjusted the following traits for batch effects:
`r cat(colnames(num.cds)[cds.idx], sep = "\n")`

```{r no_adj}
adj.cds <- num.cds 
```

```{r adj_batch_covar}
if(batch_as_covar){
    adj.cds <- adjust(num.cds, cds.covar[,1:ncol(cds.covar)-1])
}
```

```{r mean_sd}

if(b6_correction){
    batch.mean <- sapply(b6.by.batch, function(x) sapply(x, mean))
    batch.sd <- sapply(b6.by.batch, function(x) sapply(x, sd))
    batch.sd[which(is.na(batch.sd))] <- 1

    #for each batch
    for(b in c(1:(ncol(cds.covar)-1))){
        batch.idx <- which(cds.covar[,b] == 1)
        for(j in cds.idx){ #only correct classical and global
            if(exclude.zeros){
                    nonzero.idx <- which(num.cds[,j] != 0)
                }else{
                    nonzero.idx <- 1:nrow(num.cds)
                }
            adj.idx <- intersect(batch.idx, nonzero.idx)
            adj.cds[adj.idx,j] <- (num.cds[adj.idx,j] - batch.mean[b,j])/batch.sd[b,j]
        }
    }
    
}
```


### Age at D0 {.tabset .tabset-fade .tabset-pills}

Another one of our covariates is Age.at.D0.

The following boxplot shows that age varies significantly 
by batch.

```{r age_by_batch}
age <- cds.covar[,ncol(cds.covar)]
age.by.batch <- lapply(1:(ncol(cds.covar)-1), function(x) age[which(cds.covar[,x] == 1)])
p.val <- aov.by.list(age.by.batch)$"Pr(>F)"[1]

boxplot(age.by.batch, main = paste("Age at D0 by batch\n", "p =", signif(p.val, 2)))
stripchart(age.by.batch, vertical = TRUE, method = "jitter", pch = 16, 
    col = "#756bb1", add = TRUE)
```

The following plots show the relationship between Age.at.D0
and each CDS after adjusting for batch.

```{r age_at_day0, results = "asis", fig.width = 8, fig.height = 8}

u_age <- unique(cds.covar[,"Age.at.D0"])
age.idx <- lapply(u_age, function(x) which(cds.covar[,"Age.at.D0"] == x))
cds.by.age <- lapply(age.idx, function(x) adj.cds[x,,drop=FALSE])

par(mfrow = c(2,2))
for(i in 1:3){
    just.one <- lapply(cds.by.age, function(x) x[,i])
    x.vals <- lapply(1:length(just.one), function(x) rep(u_age[x], length(just.one[[x]])))
    x <- unlist(x.vals)
    y <- unlist(just.one)
    if(exclude.zeros){
        nonzero.idx <- which(y != 0)
    }else{
        nonzero.idx <- 1:length(y)
    }

    plot.with.model(x[nonzero.idx], y[nonzero.idx], xlab = "Age at D0", 
        ylab = colnames(num.cds)[i], main = colnames(num.cds)[i])
}
```


```{r adjust_age, eval = FALSE}
#adjust for age
for(i in 1:ncol(adj.cds)){
    if(exclude.zeros){
        nonzero.idx <- which(num.cds[,i] != 0)
    }else{
        nonzero.idx <- 1:nrow(num.cds)
    }
    adj.cds[nonzero.idx,i] <- adjust(adj.cds[nonzero.idx,i,drop=FALSE], 
        cds.covar[nonzero.idx,"Age.at.D0",drop=FALSE])
}
```

```{r write_adj}
#write out the results of whatever adjustments we have done
write.table(adj.cds, file.path(results.dir, "Adj_CDS.csv"), sep = ",", quote = FALSE)
```

Rank Z normalize the CDS scores if this is specified.

```{r no_norm}
norm.cds <- adj.cds
colnames(norm.cds) <- gsub(".CDS", "", colnames(norm.cds)) #take off CDS in labels, to save room in plots
```

```{r norm}
if(rank_norm){
    for(i in 1:ncol(norm.cds)){
        if(exclude.zeros){
            nonzero.idx <- which(num.cds[,i] != 0)
        }else{
            nonzero.idx <- 1:nrow(num.cds)
        }
        norm.cds[nonzero.idx,i] <- rankZ(adj.cds[nonzero.idx,i])
    }
}
colnames(norm.cds) <- gsub(".CDS", "", colnames(norm.cds)) #take off CDS, to save room in plots

#write out normzliaed values
write.table(norm.cds, file.path(results.dir, "Norm_CDS.csv"), sep = ",", quote = FALSE)

```

### Normalized Scores {.tabset .tabset-fade .tabset-pills}

The following plots show the distribution of each 
disease score after adjustments and normalization.

```{r norm_dist, fig.width = 10, fig.height = 5, results = "asis"}
#ymin = min(norm.cds);ymax = max(norm.cds) #all on same axes
ymin = NULL; ymax = NULL #all on independend axes
for(cd in 1:ncol(norm.cds)){
    cat("####", colnames(norm.cds)[cd], "\n")
    plot_cds_by_strain(scores = norm.cds[,cd], 
        strain.labels = factor.cds[,"Strain"], exclude.zeros = exclude.zeros,
        ymin = ymin, ymax = ymax, plot.label = colnames(num.cds)[cd])
    cat("\n\n")
}

```

## CC genotypes

Get the CC genotypes from the qtl2 github website, convert
to genoprobs, and calculate kinship matrices.

```{r get_CC_genotypes, warning = FALSE}
cc.geno <- readRDS(here("Data", "MRCA10_modelprobs_trim.rds"))

map.file <- here("Data", "map.RDS")
new.geno.file <- here("Data", "genoprobs.RDS")
k.file <- here("Data", "kinship_loco.RDS")

if(!file.exists(map.file)){
    file <- paste0("https://raw.githubusercontent.com/rqtl/", "qtl2data/master/CC/cc.zip")
    cc <- read_cross2(file)
    map <- map
    saveRDS(map, map.file)
    
    cc.official <- rownames(cc$geno[[1]])
    cc.alias <- sapply(strsplit(cc.official, "/"), function(x) x[1])
    write.table(cbind(cc.official, cc.alias), here("Data", "CC_names.txt"), sep = "\t", 
        quote = FALSE, row.names = FALSE, col.names = FALSE)
    
    cc.genoprobs <- calc_genoprob(cc, cores = cores)    
    new.genoprobs <- cc.genoprobs

    #add strains 83 and 84 to the genoprobs 
    new.strains <- c("CC083", "CC084")
    new.strain.idx <- match(new.strains, rownames(cc.geno))
    for(i in 1:length(cc.genoprobs)){
        chr.markers <- dimnames(cc.genoprobs[[i]])[[3]]
        common.markers <- intersect(chr.markers, dimnames(cc.geno)[[3]])
        orig.idx <- match(common.markers, dimnames(cc.genoprobs[[i]])[[3]])
        new.idx <- match(common.markers, dimnames(cc.geno)[[3]])
        new.chr <- abind(cc.genoprobs[[i]][,,orig.idx], cc.geno[new.strain.idx,,new.idx], along = 1)
        new.genoprobs[[i]] <- new.chr
    }
    saveRDS(new.genoprobs, new.geno.file)

    #overwrite the original objecct
    cc.genoprobs <- new.genoprobs

    K <- calc_kinship(new.genoprobs, "loco")
    saveRDS(K, k.file)
}else{
    map <- readRDS(map.file)
    cc.genoprobs <- readRDS(new.geno.file)
    K <- readRDS(k.file)
}
```

If specified, add genoptypes for 129, NOD, and B6, so we 
can use them in mapping.

```{r add_other_strains}
if(add_founder_genotypes){
    founder_fun <- function(strain.name){
        founder.genotypes <- rep(0, length(strain.colors))
        founder.idx <- which(names(strain.colors) == strain.name)
        founder.genotypes[founder.idx] <- 1
        return(founder.genotypes)
    }

    strain.129 <- founder_fun("129")
    strain.b6 <- founder_fun("B6")
    strain.nod <- founder_fun("NOD")

    mapping.genoprobs  <- cc.genoprobs
    for(i in 1:length(cc.genoprobs)){
        ind.129 <- matrix(strain.129, nrow = ncol(cc.genoprobs[[i]]), 
            ncol = dim(cc.genoprobs[[i]])[3])
        ind.b6 <- matrix(strain.b6, nrow = ncol(cc.genoprobs[[i]]), 
            ncol = dim(cc.genoprobs[[i]])[3])
        ind.nod <- matrix(strain.nod, nrow = ncol(cc.genoprobs[[i]]), 
            ncol = dim(cc.genoprobs[[i]])[3])
        new.chr <- abind(cc.genoprobs[[i]], ind.129, ind.b6, ind.nod, along = 1)
        rownames(new.chr)[tail(1:length(rownames(new.chr)), 3)] <- c("129", "C57BL6", "NOD")
        mapping.genoprobs[[i]] <- new.chr
    }

    #recalculate K for the new genoprobs.
    mapping.K <- calc_kinship(mapping.genoprobs, "loco")
    mapping.strains <- eae.strains
}else{
    mapping.genoprobs <- cc.genoprobs
    mapping.K <- K
    mapping.strains <- eae.strains[grep("CC", eae.strains)]
}

```

## Allele Frequencies  {.tabset .tabset-fade .tabset-pills}

The following plots show the frequencies of each founder 
allele across each chromosome. Regions in which the allele
frequencies are imbalanced may not be good for mapping.

```{r allele_freq, results = "asis", fig.width = 8, fig.height = 4}
allele_freq <- lapply(mapping.genoprobs, function(x) apply(x, 3, colMeans))
for(ch in 1:length(allele_freq)){
    cat("### Chr", names(map)[[ch]], "\n")
    layout(matrix(c(1,2), nrow = 1), widths = c(1,0.3))
    par(mar = c(4,4,4,0))
    plot.new()
    plot.window(xlim = c(0, max(map[[ch]])), ylim = c(0,0.4))
    for(a in 1:nrow(allele_freq[[ch]])){
        points(map[[ch]][dimnames(mapping.genoprobs[[ch]])[[3]]], 
        allele_freq[[ch]][a,], col = strain.colors[a], type = "l", lwd = 2)
    }
    abline(h = 0)
    axis(1)
    axis(2)
    mtext(paste("Chr", names(map)[[ch]]))
    plot.new()
    plot.window(xlim = c(0,1), ylim = c(0,1))
    par(mar = c(4,0,4,0))
    legend(x = 0, y = 1, lty = 1, col = strain.colors, legend = names(strain.colors), 
        horiz = FALSE, bg = "white", lwd = 2, adj = 0)
    cat("\n\n")
}
```

## Sex Effects Plotted by Individual {.tabset .tabset-fade .tabset-pills}

The following plots show the trait distributions for each
strain. Each plot is ordered by overall strain mean.

For each strain, the dots are split and colored by sex. 
Each point represents one mouse. The horizontal line
shows the mean value for that sex. This helps show
where there might be sex effects in individual strains.


```{r trait_fun}
#This function puts the given trait into a list based
#on strain and plots it if desired.
trait_list <- function(strain.tables, trait.name, exclude.zeros = TRUE, 
    col.by = NULL, plot.results = TRUE){

    if(length(col.by) == 0){col.by = rep("gray", sum(sapply(strain.tables, nrow)))}
    if(length(col.by) == 1){col.by = rep(col.by, sum(sapply(strain.tables, nrow)))}
    u_cols <- unique(col.by)

    if(length(u_cols) > 1){
        col.seg <- segment.region(-0.15, 0.15, length(u_cols), "ends")
    }else{
        col.seg <- 0
    }

    strain.trait <- lapply(strain.tables, function(x) x[,trait.name])
    names(strain.trait) <- names(strain.tables)

    if(exclude.zeros){
        #remove 0, to do CDS only
        nonzero.idx <- which(unlist(strain.trait) != 0) #find indices to remove from other variables
        strain.trait <- lapply(strain.trait, function(x) x[which(x != 0)]) #remove zeros
    }else{
        nonzero.idx <- 1:length(unlist(strain.trait))
    }
    col.by <- col.by[nonzero.idx]

    trait.mean <- sapply(strain.trait, mean)
    trait.order <- order(trait.mean)

    plot.idx <- unlist(lapply(1:length(strain.trait), function(x) rep(x, length(strain.trait[[x]]))))

    if(plot.results){
        ymin <- min(unlist(strain.trait), na.rm = TRUE)
        ymax <- max(unlist(strain.trait), na.rm = TRUE)

        plot.new()
        plot.window(xlim = c(1,length(strain.tables)), ylim = c(ymin, ymax))
        x <- 1
        for(i in trait.order){
            #plot the colors separately so we can see them better
            for(j in 1:length(u_cols)){
                ind.idx <- which(plot.idx == i)
                col.idx <- which(col.by[ind.idx] == u_cols[j])
                points(rep(x+col.seg[j], length(col.idx)), 
                    strain.trait[[i]][col.idx], col = u_cols[j], pch = 16)
                points(x+col.seg[j], 
                    mean(strain.trait[[i]][col.idx]), col = u_cols[j], pch = "-", cex = 2)
                #segments(x0 = x+col.seg[j], y0 = ymin, y1 = ymax, col = u_cols[j])
                segments(x0 = x+0.5, y0 = ymin, y1 = ymax, col = "gray")
            }
            x <- x + 1
        }
        axis(2)
        par(xpd = TRUE)
        text(x = 1:length(strain.trait), y = rep(ymin, length(strain.trait)), 
            labels = names(strain.trait)[trait.order], srt = 90, adj = 1)
        par(xpd = FALSE)
        mtext(trait.name, side = 3, line = 2, font = 2)
        #stripchart(strain.trait[trait.order], vertical = TRUE, pch = 16, method = "jitter", las = 2, main = trait.name, ylab = trait.name)
    }
    return(strain.trait)
}

#This function plots the mean by the col.by argument
#and tests for statistical differences between these
#means. It returns a vector of p values, one for each
#strain.
trait_bars <- function(strain.tables, trait.name, exclude.zeros = TRUE,
    col.by = NULL, plot.results = TRUE){

    if(length(col.by) == 0){col.by = rep("gray", sum(sapply(strain.tables, nrow)))}
    if(length(col.by) == 1){col.by = rep(col.by, sum(sapply(strain.tables, nrow)))}
    u_cols <- unique(col.by)
    col.seg <- segment.region(-0.15, 0.15, length(u_cols), "ends")

    strain.trait <- lapply(strain.tables, function(x) x[,trait.name])
    names(strain.trait) <- names(strain.tables)

    if(exclude.zeros){
        #remove 0, to do CDS only
        nonzero.idx <- which(unlist(strain.trait) != 0) #find indices to remove from other variables
        strain.trait <- lapply(strain.trait, function(x) x[which(x != 0)]) #remove zeros
    }else{
        nonzero.idx <- 1:length(unlist(strain.trait))
    }
    col.by <- col.by[nonzero.idx]

    trait.mean <- sapply(strain.trait, mean)
    trait.order <- order(trait.mean)

    plot.idx <- unlist(lapply(1:length(strain.trait), function(x) rep(x, length(strain.trait[[x]]))))
    diff.p <- rep(NA, length(strain.tables))
    names(diff.p) <- names(strain.tables)[trait.order]
    
    if(plot.results){
        ymin <- min(unlist(strain.trait), na.rm = TRUE)
        ymax <- max(unlist(strain.trait), na.rm = TRUE)

        plot.new()
        plot.window(xlim = c(1,length(strain.tables)), ylim = c(ymin, ymax))
        x <- 1
        for(i in trait.order){
            #plot the colors separately so we can see them better
            test.diff <- vector(mode = "list", length = length(u_cols))
            for(j in 1:length(u_cols)){
                ind.idx <- which(plot.idx == i)
                col.idx <- which(col.by[ind.idx] == u_cols[j])
                points(x+col.seg[j], 
                    mean(strain.trait[[i]][col.idx]), col = u_cols[j], type = "h",
                    lwd = 3)
                test.diff[[j]] <- strain.trait[[i]][col.idx]
                #segments(x0 = x+col.seg[j], y0 = ymin, y1 = ymax, col = u_cols[j])
                segments(x0 = x+0.5, y0 = ymin, y1 = ymax, col = "gray")
            }
            if(all(sapply(test.diff, length) > 1)){
                test <- aov.by.list(test.diff)
                diff.p[x] <- test[1,"Pr(>F)"]
            }
            x <- x + 1
        }
        axis(2)
        par(xpd = TRUE)
        text(x = 1:length(strain.trait), y = rep(ymin, length(strain.trait)), 
            labels = names(strain.trait)[trait.order], srt = 90, adj = 1)
        par(xpd = FALSE)
        mtext(trait.name, side = 3, line = 2, font = 2)
        abline(h = 0)
        #stripchart(strain.trait[trait.order], vertical = TRUE, pch = 16, method = "jitter", las = 2, main = trait.name, ylab = trait.name)
    }
    return(diff.p)
}
```

```{r trait_dist}
strain.tables <- lapply(mapping.strains, function(x) norm.cds[which(cds[,1] == x),])
strain.factors <- lapply(mapping.strains, function(x) factor.cds[which(cds[,1] == x),])
names(strain.tables) <- names(strain.factors) <- mapping.strains
```

### Classical

```{r dots_classical, fig.width = 10, fig.height = 5}
sex.col <- as.numeric(as.factor(unlist(lapply(strain.factors, function(x) x[,"Sex"]))))

strain.classical <- trait_list(strain.tables, "Classical", col.by = sex.col+2, 
    exclude.zeros = exclude.zeros)
legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
    bg = "white")
```

### AR

```{r dots_ar, fig.width = 10, fig.height = 5}
strain.ar  <- trait_list(strain.tables, "AR", col.by = sex.col+2,
    exclude.zeros = exclude.zeros)
legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
    bg = "white")
```

### Global

```{r dots_global, fig.width = 10, fig.height = 5}
strain.global <- trait_list(strain.tables, "Global",col.by = sex.col+2, 
    exclude.zeros = exclude.zeros)
legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
    bg = "white")
```

## Sex Effects by Strain {.tabset .tabset-fade .tabset-pills}

The following plots distill the above figures to just the 
means for each sex. This makes it easier to see where the
means for the two sexes are different. 

An imbalance of sex effects in the different strains could
lead to strange mapping patterns (I think).

The top plot for each shows the means for each sex and each
strain. The strains are ordered by overall strain mean.

The middle plot shows the -log10 of the p value for each 
difference. The solid line shows the p = 0.05 threshold,
and the dashed line shows the bon ferroni adjust p value
threshold.

The bottom dot plot shows a direct comparison of 
female means vs. male means for each strain and 
each trait. Strains with a large difference between
male and female (90th percentile) are labeled.

Overall there is no difference between the sexes.
However, a few strains have large sex biases. 
For CC044, CC075, and CC072, females tend to have a
larger disease score. For CC042, the males tend to
have a larger disease score.

### Classical

```{r plot_bars_fun}

plot_bars <- function(trait.name, exclude.zeros){
    layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.5))
    par(mar = c(3,4,4,4))
    classical.p <- trait_bars(strain.tables, trait.name, col.by = sex.col+2, 
        exclude.zeros = exclude.zeros)
    legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
        bg = "white")
    par(mar = c(4,3.5,0,3.5))
    p.thresh <- c(-log10(0.05), -log10(0.05/length(strain.tables)))
    ymax <- max(c(p.thresh, -log10(classical.p)), na.rm = TRUE)
    ymax <- ceiling(ymax*1)/1
    a <- barplot(-log10(classical.p), las = 2, ylim = c(0, ymax))
    mtext("-log10(p) for sex difference", side = 2, line = 2.5)
    segments(x0 = rep(0, length(p.thresh)), x1 = rep(max(a[,1]), length(p.thresh)), 
        y0 = p.thresh, lty = c(1,2))
    par(xpd = TRUE)
    text(x = max(a[,1]), y = -log10(0.05), labels = "0.05", adj = 0)
    text(x = max(a[,1]), y = -log10(0.05/length(strain.tables)), labels = "corrected", adj = 0)
    par(xpd = FALSE)
}
```

```{r plot_dots}
plot_dots <- function(trait.name, diff.percentile = 90){

    f.vals <- lapply(1:length(strain.factors), function(x) strain.tables[[x]][which(strain.factors[[x]][,"Sex"] == "F"),trait.name])
    m.vals <- lapply(1:length(strain.factors), function(x) strain.tables[[x]][which(strain.factors[[x]][,"Sex"] == "M"),trait.name])

    f.means <- sapply(f.vals, mean)
    m.means <- sapply(m.vals, mean)

    diffs <- abs(f.means - m.means)
    diff.thresh <- get.percentile(diffs, diff.percentile)
    big.diffs <- which(diffs >= diff.thresh)

    plot(f.means, m.means, pch = 16, xlab = "Female Mean", ylab = "Male Mean",
    main = trait.name)
    abline(0,1)
    text(f.means[big.diffs], m.means[big.diffs], labels = names(strain.factors)[big.diffs],
        pos = 2)
    
}
```

```{r bars_classical, fig.width = 10, fig.height = 7}
plot_bars("Classical", exclude.zeros = exclude.zeros)
```

```{r dots_comp_classical}
plot_dots("Classical")
```


### AR

```{r bars_ar, fig.width = 10, fig.height = 7}
plot_bars("AR", exclude.zeros = exclude.zeros)
```

```{r dots_comp_ar}
plot_dots("AR")
```


### Global

```{r bars_global, fig.width = 10, fig.height = 7}
plot_bars("Global", exclude.zeros = exclude.zeros)
```

```{r dots_comp_global}
plot_dots("Global")
```


### Overall Sex Effect

```{r sex_diff, fig.height = 8, fig.width = 8}
#quartz(width = 8, height = 8)
par(mfrow = c(2,2))
for(i in 1:ncol(norm.cds)){
    if(exclude.zeros){
        nonzero.idx <- which(norm.cds[,i] != 0)
    }else{
        nonzero.idx <- 1:nrow(norm.cds)
    }
    model <- lm(norm.cds[nonzero.idx,i]~as.factor(factor.cds[nonzero.idx,"Sex"]))
    f <- summary(model)$fstatistic
    p <- pf(f[1],f[2],f[3],lower.tail=F)
    boxplot(norm.cds[nonzero.idx,i]~as.factor(factor.cds[nonzero.idx,"Sex"]), 
        ylab = colnames(norm.cds)[i],
        main = paste(colnames(norm.cds)[i], "\np =", signif(p, 2)), xlab = "")
}
```

## CDS Trait Correlations

The following plot shows that global CDS
is dominated by classical disease.
It also shows that CDS in classical 
disease and AR are unrelated to each other.

```{r trait_cor, fig.width = 8, fig.height = 8}
trait.pairs <- pair.matrix(1:ncol(norm.cds))
par(mfrow = c(2,2))
for(i in 1:nrow(trait.pairs)){
    trait1 <- trait.pairs[i,1]
    trait2 <- trait.pairs[i,2]
    if(exclude.zeros){
        nonzero.idx <- intersect(which(norm.cds[,trait1] != 0), which(norm.cds[,trait2] != 0))
    }else{
        nonzero.idx <- 1:nrow(norm.cds)
    }
    plot.with.model(norm.cds[nonzero.idx,trait1], norm.cds[nonzero.idx,trait2],
        xlab = colnames(norm.cds)[trait1], ylab = colnames(norm.cds)[trait2],
        main = paste(colnames(norm.cds)[trait1], "vs.", colnames(norm.cds)[trait2]))
}
```

## Map CDS with Individuals

We mapped each CDS across the individual mice. 

```{r methods}
if(add_founder_genotypes){
    methods.line <- "Both CC and founder strains were used for mapping."
}else{
    methods.line <- "We used only CC strains for mapping."
}

if(length(remove_strains) != 0){
    remove.line <- paste("We excluded the following strains:", paste(remove_strains, collapse = ", "))
}else{
    remove.line <- "No CC strains were excluded."
}
```

`r methods.line`
`r remove.line`

For the genoprobs and kinship matrices, we copied
the entries for the individuals in each strain and
used indices for row names.

The LOD traces for each trait are shown below along 
with plots for the FDR results. Significance thresholds
from the permutations are also shown on the LOD traces.

```{r expand_matrices}

if(length(remove_strains) != 0){
    remove.idx <- sapply(remove_strains, function(x) which(mapping.strains == x))
    mapping.strains <- mapping.strains[-remove.idx]
}

pheno.strains <- unlist(sapply(mapping.strains, function(x) pheno.strains[grep(x, pheno.strains)]))

K.idx <- sapply(mapping.strains, function(x) grep(x, rownames(mapping.K[[1]])))
K.num <- sapply(mapping.strains, function(x) length(which(pheno.strains == x)))
expanded.idx <- unlist(lapply(1:length(K.idx), function(x) rep(K.idx[x], K.num[x])))
groups <- names(expanded.idx)

exp.K <- lapply(1:length(mapping.K), function(x) mapping.K[[x]][expanded.idx,expanded.idx])
names(exp.K) <- names(mapping.K)

#create unique row and column names
for(i in 1:length(exp.K)){
    rownames(exp.K[[i]]) <- colnames(exp.K[[i]]) <- 1:length(expanded.idx)
}

expanded.genoprobs <- mapping.genoprobs
for(i in 1:length(expanded.genoprobs)){
    expanded.genoprobs[[i]] <- mapping.genoprobs[[i]][expanded.idx,,]
    rownames(expanded.genoprobs[[i]]) <- 1:length(expanded.idx)
}

#align the phenotypes with the strains
pheno.idx <- which(cds[,1] %in% pheno.strains)

pheno.idx <- which(cds[,1] %in% pheno.strains)
covar <- matrix(as.numeric(as.factor(cds[pheno.idx,"Sex"])), ncol = 1)
rownames(covar) <- 1:length(covar)

#test <- cds[pheno.idx,]

mapping.pheno <- norm.cds[pheno.idx,]
rownames(mapping.pheno) <- 1:length(expanded.idx)

mapping.factors <- factor.cds[pheno.idx,]
mapping.covar <- matrix(as.numeric(as.factor(mapping.factors[,"Sex"])), ncol = 1)
rownames(mapping.covar) <- 1:nrow(mapping.covar)
```

### Heritability

The heritability of CDS is shown below.

```{r herit, fig.width = 5, fig.height = 5}
overall.k.file <- here("Data", "kinship_overall.RDS")
if(!file.exists(overall.k.file) || overwrite_previous){
    overall.K <- calc_kinship(expanded.genoprobs, "overall")
    saveRDS(overall.K, overall.k.file)
}else{
    overall.K <- readRDS(overall.k.file)
}

ind.herit <- rep(NA, ncol(num.cds))
names(ind.herit) <- colnames(num.cds)
for(i in 1:ncol(num.cds)){
    nonzero.idx <- which(mapping.pheno[,i] != 0)
    ind.herit[i] <- est_herit(mapping.pheno[nonzero.idx,i,drop=FALSE], overall.K)
}

barplot_with_num(round(ind.herit, 2), ylab = "Heritability", xlab = "", 
    ylim = c(0, 0.4), text.shift = 0.09, main = "Trait Heritability Estimates")
```

```{r mapping_fun}

map_pheno <- function(map.geno, map.pheno, map.K, addcovar = NULL,
    intcovar = NULL, groups = NULL, exclude.zeros = TRUE, 
    results.file = file.path(results.dir, "scan1_results.RDS")){

    if(!file.exists(results.file) || overwrite_previous){
        pheno.scans <- vector(mode = "list", length = ncol(map.pheno))
        names(pheno.scans) <- colnames(map.pheno)
        for(ph in 1:ncol(map.pheno)){
            if(exclude.zeros){
                nonzero.idx <- which(map.pheno[,ph] != 0)
            }else{
                nonzero.idx <- 1:nrow(map.pheno)
            }
            pheno.scans[[ph]] <- scan1(map.geno, map.pheno[nonzero.idx,ph], 
                addcovar = addcovar, intcovar = intcovar, kinship = map.K)
            #plot(pheno.scans[[ph]], map = map)
        }
        saveRDS(pheno.scans, results.file)
    }else{
        pheno.scans <- readRDS(results.file)
    }
    return(pheno.scans)
}


perm_scans <- function(map.geno, map.pheno, map.k, scan1.results, 
    addcovar = NULL, intcovar = NULL, groups = NULL, nperm = nperm, 
    max.exp.lod = 20, n.founders = 8, exclude.zeros = TRUE, 
    results.file = file.path(results.dir, "perm.RDS")){

    #permutations for Matt's FDR method (see https://github.com/j-matthew-mahoney/cdf-fdrci.git)
    #right now this does one phenotype at a time, but we can change that later.
    perm.data <- vector(mode = "list", length = ncol(map.pheno))
    nind = nrow(map.pheno)
    #bin possible LOD scores
    breaks = lod2p(seq(max.exp.lod, 0, -0.01), nind = nind, k = n.founders)

    if(!file.exists(results.file)){
        for(ph in 1:ncol(map.pheno)){
            if(exclude.zeros){
                nonzero.idx <- which(map.pheno[,ph] != 0)
            }else{
                nonzero.idx <- 1:nrow(map.pheno)
            }
            if(!is.null(groups)){
                null_stats = scan1_groupperm_stats(map.geno, 
                    pheno = map.pheno[nonzero.idx,ph,drop=FALSE], 
                    groups = groups[nonzero.idx],
                    kinship = map.k, nperm = nperm, breaks = breaks, 
                    addcovar = addcovar, intcovar = intcovar,
                    scan1_out = scan1.results[[ph]][,1,drop=FALSE], cores = cores)
            }else{
                null_stats = scan1perm_stats(map.geno, 
                    pheno = map.pheno[nonzero.idx,ph,drop=FALSE], 
                    kinship = map.k, nperm = nperm, breaks = breaks,
                    addcovar = addcovar, intcovar = intcovar,
                    scan1_out = scan1.results[[ph]][,1,drop=FALSE], cores = cores)
            }
            perm.data[[ph]] <- null_stats
        }
        saveRDS(perm.data, results.file)
    }else{
        perm.data <- readRDS(results.file)
    }
    return(perm.data)
}


plot_fdr_fun <- function(scan.results, perm.results, tab.level = "###"){

    fdr_summaries <- matrix(NA, nrow = length(scan.results), ncol = 5)
    rownames(fdr_summaries) <- names(scan.results)
    for(ph in 1:length(scan.results)){
        cat(tab.level, names(scan.results)[ph], "\n")
        summary_thresholds = fdr_summarize(perm.results[[ph]], fdr_cl = 0.95, 
            geno_sig = c(0.01, 0.05), fdr_thresh = c(0.1, 0.2, 0.4), 
            plot = TRUE, quartz = FALSE)

        finite.thresh <- which(is.finite(summary_thresholds))

        maxy <- max(c(scan.results[[ph]][,1], 
            summary_thresholds[finite.thresh], na.rm = TRUE))*1.1
        par(mar = c(4, 4, 4, 8))
        plot(scan.results[[ph]], map = map, main = names(scan.results)[ph], 
            ylim = c(0, maxy))
        abline(h = summary_thresholds)
        plot.dim <- par("usr")
        par(xpd = TRUE)
        text(x = plot.dim[2], y = summary_thresholds[finite.thresh], 
            labels = names(summary_thresholds)[finite.thresh], cex = 0.5, adj = 0)
        par(xpd = FALSE)
        fdr_summaries[ph,] <- summary_thresholds
        cat("\n\n")
    }
    colnames(fdr_summaries) <- names(summary_thresholds)
    invisible(fdr_summaries)
}

select_threshold <- function(scan.results, fdr_summaries){
    for(ph in 1:length(scan.results)){
        finite.thresh <- fdr_summaries[ph,which(is.finite(fdr_summaries[ph,]))]
        peak.tables <- lapply()
    }

}

allele_coef <- function(map.geno, map.pheno, map.k, addcovar = NULL,
    intcovar = NULL, scan.results, lod.threshold, exclude.zeros, 
    chr.lod.file, chr.coef.file){

    peak.table <- lapply(1:length(scan.results), 
        function(x) find_peaks(scan.results[[x]], map = map, 
        threshold = lod.threshold[x]))

    if(!file.exists(chr.lod.file) || overwrite_previous){
        chr.lod <- chr.coef <- vector(mode = "list", length = nrow(Reduce("rbind", peak.table)))
        idx = 1
        for(ph in 1:length(peak.table)){
            if(nrow(peak.table[[ph]]) != 0){
                for(p in 1:nrow(peak.table[[ph]])){
                    chr <- peak.table[[ph]][p,"chr"]
                    peak.loc <- peak.table[[ph]][p,"pos"]
                    trait = names(scan.results)[ph]
                    chr.locale <- which(names(map.geno) == chr)

                    if(exclude.zeros){
                        nonzero.idx <- which(map.pheno[,ph] != 0)
                    }else{
                        nonzero.idx <- 1:nrow(map.pheno)
                    }
                    chr.scan <- scan1(map.geno[,chr], 
                        map.pheno[nonzero.idx,ph,drop=FALSE], 
                        kinship = map.k[[chr.locale]], addcovar = addcovar,
                        intcovar = intcovar)
                    chr.lod[[idx]] <- chr.scan
                    #plot(chr.scan, map = map);abline(v = peak.loc)

                    effects.scan <- scan1blup(map.geno[,chr], 
                        map.pheno[nonzero.idx,ph,drop=FALSE], 
                        kinship = map.k[[chr.locale]], addcovar = addcovar)
                    chr.coef[[idx]] <- effects.scan
                    #plot_coefCC(effects.scan, map = map);abline(v = peak.loc)
                    idx = idx + 1 #increment regardless of whether there is a peak here
                }
                
            }
        }
        saveRDS(chr.lod, chr.lod.file)
        saveRDS(chr.coef, chr.coef.file)
    }else{
        chr.lod <- readRDS(chr.lod.file)
        chr.coef <- readRDS(chr.coef.file)
    }
    result <- list("peak.table" = peak.table, "LOD" = chr.lod, "Coef" = chr.coef)
    return(result)
}

plot_coef_scans <- function(coef.results, map.geno, map.pheno, fdr_results = NULL,
    tab.level = "###", sig_lines = c("Genome-wide", "FDR")){
    
    if(!is.null(fdr_results)){
        sig_lines = sig_lines[1]
        line.idx <- grep(sig_lines, colnames(fdr_results))
    }

    peak.table <- coef.results$peak.table
    chr.lod <- coef.results$LOD
    chr.coef <- coef.results$Coef

    idx <- 1
    for(ph in 1:length(peak.table)){
        if(nrow(peak.table[[ph]]) != 0){
            for(p in 1:nrow(peak.table[[ph]])){
                par(mfrow = c(2,1))
                chr <- peak.table[[ph]][p,"chr"]
                trait <- colnames(map.pheno)[ph]
                peak.loc <- peak.table[[ph]][p,"pos"]
                chr.locale <- which(names(map.geno) == chr)
                
                cat(tab.level, trait, "Chr", chr, "\n")

                if(!is.null(fdr_results)){
                    ymax <- max(c(chr.lod[[idx]], fdr_results[ph,line.idx]))
                }else{
                    ymax <- max(chr.lod[[idx]])
                }
                plot(chr.lod[[idx]], map = map, main = paste(trait, "Chr", chr), 
                    ylim = c(0, ymax*1.05))
                if(!is.null(fdr_results)){
                    abline(h = fdr_results[ph,line.idx])
                
                    plot.dim <- par("usr")
                    par(xpd = TRUE)
                    text(x = plot.dim[2], y = fdr_results[ph,line.idx], 
                        labels = gsub(paste0(sig_lines, " "), "", colnames(fdr_results)[line.idx]), 
                        cex = 0.5, adj = 0)
                }
                par(xpd = FALSE)


                plot_coefCC(chr.coef[[idx]], map = map, main = paste(trait, "Chr", chr),
                    col = strain.colors)
                abline(v = peak.loc, lwd = 2)

                idx = idx + 1
                cat("\n\n")
            }
        }
    }
}

```

```{r map_cds, warning = FALSE}
cds.scans <- map_pheno(expanded.genoprobs, mapping.pheno, exp.K, 
    addcovar = covar, exclude.zeros = exclude.zeros, 
    results.file = file.path(results.dir, "scan1_results_cds.RDS"))

if(run_permutations){
    cds.perm <- perm_scans(expanded.genoprobs, mapping.pheno, exp.K,
        cds.scans, addcovar = covar, groups = names(expanded.idx), 
        exclude.zeros = exclude.zeros, nperm = nperm, 
        results.file = file.path(results.dir, "scan1perm_results_cds.RDS"))
}
```


### CDS by individual LOD traces {.tabset .tabset-fade .tabset-pills}

```{r plot_cds_scans, fig.width = 9, fig.height = 5, warning = FALSE, results = "asis"}
#plot the scans, and FDR results
if(run_permutations){
    fdr_summaries_cds <- plot_fdr_fun(cds.scans, cds.perm, 
        tab.level = "####")
}else{
    for(i in 1:length(cds.scans)){
        cat("####", names(cds.scans)[i], "\n")
        plot(cds.scans[[i]], map = map)
        cat("\n\n")
    }
}
```

### CDS by individual allele effects {.tabset .tabset-fade .tabset-pills}

```{r thresh}
allele.thresh = c(5,7,5)
```

The following plots show the allele effects for the largest
QTL for each trait.

```{r scan_coef, fig.width = 7, fig.height = 7, results = "asis", eval = FALSE}
cds.coef <- allele_coef(map.geno = expanded.genoprobs, 
    map.pheno = mapping.pheno, map.k = exp.K, addcovar = mapping.covar,
    scan.results = cds.scans,
    lod.threshold = allele.thresh, exclude.zeros = exclude.zeros, 
    chr.lod.file = file.path(results.dir, "Chr.LOD.cds.RDS"), 
    chr.coef.file = file.path(results.dir, "Chr.Coef.cds.RDS"))

#pdf("~/Desktop/test.pdf", width = 7, height = 7)
if(run_permutations){
    plot_coef_scans(coef.results = cds.coef, 
        map.geno = expanded.genoprobs, map.pheno = mapping.pheno, 
        fdr_results = fdr_summaries_cds, tab.level = "####",
        sig_lines = "Genome-wide")
}else{
    plot_coef_scans(coef.results = cds.coef, 
        map.geno = expanded.genoprobs, map.pheno = mapping.pheno, 
        fdr_results = NULL, tab.level = "####",
        sig_lines = "Genome-wide")
}

#dev.off()
```

### LOD intervals {.tabset .tabset-fade .tabset-pills} 

The following tables show LOD peak intervals for the top 3 peaks from 
each trait.


```{r lod_peaks, results = "asis"}
top.n <- 3
for(ph in 1:length(cds.scans)){
    cat("####", names(cds.scans)[ph], "\n")
    peak.table <- find_peaks(cds.scans[[ph]], map = map, prob = 0.95)
    lod.order <- order(peak.table[,"lod"], decreasing = TRUE)
    print(kable(peak.table[lod.order[1:top.n],]))
    cat("\n\n")
}
```

## Map CDS with Strain Average (Sex Additive) 

We also used strain averages to map CDS. We calculated
the strain averages individually for each sex and used
sex as a covariate.

First we generated strain-mean versions of the genoprobs
and kinship matrices and duplicated each row for the two sexes.

```{r assign_pheno}
#try calculating strain averages from raw data
mapping.pheno <- num.cds[pheno.idx,]
```

```{r calc_avg_pheno}
#calculate average phenotypes and construct new
#genoprobs and kinship for the mean values.
genoprob.strain <- sapply(strsplit(rownames(mapping.genoprobs[[1]]), "/", fixed = TRUE), function(x) x[1])
strain.by.sex <- cbind(rep(genoprob.strain, each = 2), rep(c("F", "M"), length(genoprob.strain)))
ind.labels <- apply(strain.by.sex, 1, function(x) paste(x, collapse = "_"))
mean.genoprobs <- mapping.genoprobs
mean.K <- mapping.K
for(i in 1:length(mean.genoprobs)){
    strain.idx <- match(strain.by.sex[,1], genoprob.strain)
    mean.genoprobs[[i]] <- mapping.genoprobs[[i]][strain.idx,,]
    rownames(mean.genoprobs[[i]]) <- ind.labels
    mean.K[[i]] <- mapping.K[[i]][strain.idx, strain.idx]
    rownames(mean.K[[i]]) <- colnames(mean.K[[i]]) <- ind.labels
}

mean.pheno <- t(apply(strain.by.sex, 1, 
    function(x) colMeans(mapping.pheno[intersect(which(mapping.factors[,1] == x[1]), 
    which(mapping.factors[,2] == x[2])),], na.rm = TRUE)))
rownames(mean.pheno) <- ind.labels

mean.covar <- matrix(as.numeric(as.factor(strain.by.sex[,2])), ncol = 1)
rownames(mean.covar) <- ind.labels

#mean.pheno <- mean.pheno.old[which(!is.na(rowSums(mean.pheno.old))),]
#norm.mean.pheno <- apply(mean.pheno.old, 2, rankZ)
norm.mean.pheno <- mean.pheno
```

```{r map_cds_avg, warning = FALSE}
#do not exclude zeros for stain averages. These don't have
#the same spike in the distribution
cds.avg.scans.sex.add <- map_pheno(mean.genoprobs, norm.mean.pheno, mean.K, 
    exclude.zeros = FALSE, addcovar = mean.covar,
    results.file = file.path(results.dir, "scan1_results_cds_avg.RDS"))

if(run_permutations){
    cds.avg.scans.sex.add.perm <- perm_scans(mean.genoprobs, norm.mean.pheno, mean.K,
        cds.avg.scans.sex.add, groups = NULL, exclude.zeros = FALSE, 
        nperm = nperm, results.file = file.path(results.dir, "scan1perm_results_cds_avg.RDS"))
}
```

### LOD Traces {.tabset .tabset-fade .tabset-pills}

The following plots show the LOD traces for the strain averages of 
CDS and the significance thresholds.

```{r strain_avg_plots, fig.width = 9, fig.height = 5, results = "asis", warning = FALSE}
#pdf("~/Desktop/test.pdf")
if(run_permutations){
    fdr_summaries_sev_avg <- plot_fdr_fun(cds.avg.scans.sex.add, cds.avg.scans.sex.add.perm,
        tab.level = "####")
}else{
    for(i in 1:length(cds.avg.scans.sex.add)){
        cat("####", names(cds.avg.scans.sex.add)[i], "\n")
        plot(cds.avg.scans.sex.add[[i]], map = map, main = names(cds.avg.scans.sex.add)[i])
        cat("\n\n")
    }
}
#dev.off()
```

### Strain Average Allele Effects {.tabset .tabset-fade .tabset-pills}

```{r scan_coef_by_strain, fig.width = 7, fig.height = 7, results = "asis", eval = FALSE}

cds.avg.coef.sex.add <- allele_coef(map.geno = mean.genoprobs, 
    map.pheno = norm.mean.pheno, map.k = mean.K, scan.results = cds.avg.scans.sex.add,
    addcovar = mean.covar,
    lod.threshold = allele.thresh, exclude.zeros = FALSE, 
    chr.lod.file = file.path(results.dir, "Chr.LOD.cds.Avg.RDS"), 
    chr.coef.file = file.path(results.dir, "Chr.Coef.cds.Avg.RDS"))

if(run_permutations){
    #pdf("~/Desktop/test.pdf", width = 7, height = 7)
    plot_coef_scans(coef.results = cds.avg.coef.sex.add, 
        map.geno = mean.genoprobs, map.pheno = norm.mean.pheno, 
        fdr_results = fdr_summaries_sev_avg, tab.level = "####",
        sig_lines = "Genome-wide")
}else{
    plot_coef_scans(coef.results = cds.avg.coef.sex.add, 
        map.geno = mean.genoprobs, map.pheno = norm.mean.pheno, 
        fdr_results = NULL, tab.level = "####",
        sig_lines = "Genome-wide")
}

#dev.off()
```

### Strain Average LOD intervals {.tabset .tabset-fade .tabset-pills}

The following tables show LOD peak intervals for the top 3 peaks from 
each trait.


```{r lod_peaks_avg, results = "asis"}
top.n <- 3
for(ph in 1:length(cds.avg.scans.sex.add)){
    cat("####", names(cds.avg.scans.sex.add)[ph], "\n")
    peak.table <- find_peaks(cds.avg.scans.sex.add[[ph]], map = map, prob = 0.95)
    lod.order <- order(peak.table[,"lod"], decreasing = TRUE)
    print(kable(peak.table[lod.order[1:top.n],]))
    cat("\n\n")
}
```


## Map CDS with Strain Average (Sex Interacting)

We also used sex as an interacting covariate when
mapping CDS.

```{r map_cds_avg_by_sex, warning = FALSE}
#do not exclude zeros when using strain means. They
#don't have the same spike in the distribution
cds.avg.scans.sex.int <- map_pheno(mean.genoprobs, norm.mean.pheno, mean.K, 
    exclude.zeros = FALSE, addcovar = mean.covar, intcovar = mean.covar,
    results.file = file.path(results.dir, "scan1_results_cds_avg_by_sex_int.RDS"))

if(run_permutations){
    perm.groups <- strain.by.sex[,1]
    cds.avg.perm.sex.add <- perm_scans(map.geno = mean.genoprobs, 
        map.pheno = norm.mean.pheno, map.k = mean.K,
        scan1.results = cds.avg.scans.sex.add, addcovar = mean.covar, 
        groups = perm.groups, exclude.zeros = FALSE, nperm = nperm, 
        results.file = file.path(results.dir, "scan1perm_results_cds_avg_sex.RDS"))

    cds.avg.perm.sex.int <- perm_scans(map.geno = mean.genoprobs, 
        map.pheno = norm.mean.pheno, map.k = mean.K, max.exp.lod = 40,
        scan1.results = cds.avg.scans.sex.int, addcovar = covar, intcovar = mean.covar,
        groups = perm.groups, exclude.zeros = FALSE, nperm = nperm,
        results.file = file.path(results.dir, "scan1perm_results_cds_avg_sex_int.RDS"))
}
```

### Interactive and Additive Together {.tabset .tabset-fade .tabset-pills}

The following plots show the two LOD traces plotted on the same
plot with significance thresholds.

```{r plot_with_sig, fig.width = 9, fig.height = 5, results = "asis", warning = FALSE}

for(i in 1:length(cds.avg.scans.sex.int)){
    cat("####", names(cds.avg.scans.sex.int)[i],  "\n")
    if(run_permutations){
        sig.levels.int <- fdr_summarize(cds.avg.perm.sex.int[[i]], fdr_cl = 0.95, 
            geno_sig = c(0.01, 0.05), fdr_thresh = c(0.1, 0.2, 0.4), 
            plot = FALSE)
        sig.levels.add <- fdr_summarize(cds.avg.perm.sex.add[[i]], fdr_cl = 0.95, 
            geno_sig = c(0.01, 0.05), fdr_thresh = c(0.1, 0.2, 0.4), 
            plot = FALSE)
        ymax <- max(c(cds.avg.scans.sex.int[[i]][,1]), sig.levels.add[1], sig.levels.int[1])*1.05
    }
    if(!run_permutations || !is.finite(ymax)){
        ymax <- max(c(cds.avg.scans.sex.int[[i]][,1]))*1.05
    }
    plot(cds.avg.scans.sex.int[[i]], map = map, col = "red", 
        main = names(cds.avg.scans.sex.add)[i], ylim = c(0, ymax))
    if(run_permutations){
        abline(h = sig.levels.int, lty = 1:2, col = "red")
    }
    plot(cds.avg.scans.sex.add[[i]], map = map, add = TRUE)
    if(run_permutations){
        abline(h = sig.levels.add, lty = 1:2, col = "darkblue")
    }
    cat("\n\n")
}

```

### Interactive and Additive Differences {.tabset .tabset-fade .tabset-pills}

The figures below show the LOD scores for the additive model 
subtracted off the interactive model. The horizontal line
is the maximum of the permuted values of the additive model
subtracted off the maximum of the permuted values of the
interactive model. This isn't exactly the significance threshold
for a locus that significantly interacts with sex, but it 
gives us a rough idea of where any interacting loci are
most likely to reside.

```{r int_test, fig.width = 9, fig.height = 5, results = "asis"}
for(i in 1:length(cds.avg.scans.sex.add)){
    cat("####", names(cds.avg.scans.sex.add)[i], "\n")
    int.diff <- cds.avg.scans.sex.int[[i]] - cds.avg.scans.sex.add[[i]]
    ylim <- c(min(int.diff[,1])*1.05, max(int.diff[,1])*1.05)
    plot(int.diff, map = map, 
    main = paste(names(cds.avg.scans.sex.add)[i], "(Interactive - Additive)"), 
        ylim = ylim)

    if(run_permutations){
        int.p.dist <- -log10(cds.avg.perm.sex.int[[i]]$min_p)
        add.p.dist <- -log10(cds.avg.perm.sex.add[[i]]$min_p)
        mean.diff <- max(int.p.dist) - max(add.p.dist)
        abline(h = mean.diff)
    }
    cat("\n\n")
}


```

## Incidence {.tabset .tabset-fade .tabset-pills}

Emily calculated an incidence level for each strain as a whole
and separately by sex. Incidence values by strain are as follows.

```{r incidence, fig.width = 5, fig.height = 7, results = "asis"}
for(i in 1:length(incidence)){
    cat("###", names(incidence)[i], "\n")
    imageWithText(incidence[[i]], main = names(incidence)[i], use.pheatmap.colors = TRUE)
    cat("\n\n")
}
```


## Map Incidence

We also want to map incidence at the strain level.
There are three incidence matrices. One has the incidence
for each strain overall. The other two are split by sex.

We mapped the overall incidence per strain on its own.
Then we combined the incidence matrices split by sex 
so we could use sex as an additive and interactive 
covariate as we did with CDS.


```{r avg_geno_k}
#make genoprobs object and a kinship object for 
#the combined incidence matrix

strain.genoprobs <- mean.genoprobs
strain.K <- mean.K

just.strain <- sapply(strsplit(rownames(mean.genoprobs[[1]]), "_"), function(x) x[1])
all.cc.strains <- unique(just.strain)
strain.idx <- match(mapping.strains, just.strain)
strain.idx <- strain.idx[which(!is.na(strain.idx))]

for(i in 1:length(mean.genoprobs)){
    strain.genoprobs[[i]] <- mean.genoprobs[[i]][strain.idx,,]
    rownames(strain.genoprobs[[i]]) <- mapping.strains
    strain.K[[i]] <- mean.K[[i]][strain.idx, strain.idx]
    rownames(strain.K[[i]]) <- colnames(strain.K[[i]]) <- mapping.strains
}

```

Make an overall incidence per strain matrix
and another that has both sexes in it so we 
can play the additive/interactive game again.

We rank Z normalized the columns of each matrix
before mapping.

```{r make_mats}
incidence.strains <- rownames(incidence$incidence_strain)
incidence.strains <- gsub("/", "", gsub(" ", "", incidence.strains))
overall.inc <- apply(incidence$incidence_strain, 2, rankZ)

inc.by.sex <- rbind(incidence$incidence_female, incidence$incidence_male)
inc.by.sex <- apply(inc.by.sex, 2, rankZ)
rownames(inc.by.sex) <- paste(incidence.strains, 
    c(rep("F", nrow(incidence$incidence_female)), rep("M", nrow(incidence$incidence_male))), 
    sep = "_")
incidence.covar <- matrix(1, ncol = 1, nrow = nrow(inc.by.sex))
incidence.covar[1:nrow(incidence$incidence_female)] <- 0
rownames(incidence.covar) <- rownames(inc.by.sex)
```

```{r map_overall_inc, warning = FALSE}
inc.scan.overall <- map_pheno(strain.genoprobs, overall.inc, strain.K, 
    exclude.zeros = FALSE, 
    results.file = file.path(results.dir, "scan1_results_overall_incidence.RDS"))

if(run_permutations){    
    incidence.overall.perm <- perm_scans(strain.genoprobs, overall.inc, strain.K,
        inc.scan.overall, groups = NULL, exclude.zeros = FALSE, nperm = nperm,
        results.file = file.path(results.dir, paste0("scan1perm_results_incidence_overall.RDS")))   
}
```

```{r map_inc_by_sex_add, warning = FALSE}
inc.scan.sex.add <- map_pheno(mean.genoprobs, inc.by.sex, mean.K, 
    exclude.zeros = FALSE, addcovar = incidence.covar,
    results.file = file.path(results.dir, "scan1_results_incidence_sex_add.RDS"))

if(run_permutations){    
    incidence.sex.add.perm <- perm_scans(mean.genoprobs, inc.by.sex, mean.K,
        inc.scan.sex.add, addcovar = incidence.covar, groups = NULL, 
        exclude.zeros = FALSE, nperm = nperm,
        results.file = file.path(results.dir, paste0("scan1perm_results_incidence_sex_add.RDS")))   
}
```


```{r map_inc_by_sex_int, warning = FALSE}
inc.scan.sex.int <- map_pheno(mean.genoprobs, inc.by.sex, mean.K, 
    exclude.zeros = FALSE, addcovar = incidence.covar, intcovar = incidence.covar,
    results.file = file.path(results.dir, "scan1_results_incidence_sex_int.RDS"))

if(run_permutations){    
    incidence.sex.int.perm <- perm_scans(mean.genoprobs, inc.by.sex, mean.K,
        inc.scan.sex.add, groups = NULL, exclude.zeros = FALSE, nperm = nperm,
        addcovar = incidence.covar, intcovar = incidence.covar,
        results.file = file.path(results.dir, paste0("scan1perm_results_incidence_sex_int.RDS")))   
}
```


### LOD traces: Incidence Overall {.tabset .tabset-fade .tabset-pills}

```{r plot_inc_perm_overall, warning = FALSE, fig.height = 5, fig.width = 9, results = "asis"}
#pdf("~/Desktop/test.pdf")
if(run_permutations){
    fdr_summaries_incidence_overall <- plot_fdr_fun(inc.scan.overall, 
    incidence.overall.perm, tab.level = "####")
}else{    
    for(i in 1:length(inc.scan.overall)){
        cat("####", names(inc.scan.overall)[i], "\n")
        plot(inc.scan.overall[[i]], map = map, main = names(inc.scan.overall)[i])
        cat("\n\n")
    }
}

#dev.off()
```


### LOD Traces: Incidence With Sex Covariate {.tabset .tabset-fade .tabset-pills}


```{r plot_inc_perm_both, warning = FALSE, fig.height = 5, fig.width = 9, results = "asis"}
#pdf("~/Desktop/test.pdf")

for(i in 1:length(inc.scan.sex.int)){
    cat("####", names(inc.scan.sex.int)[i], "\n")
    if(run_permutations){
        ymax <- max(c(inc.scan.sex.int[[i]][,1]), fdr_summaries_incidence_sex_int[i,1:2])*1.05
    }else{
        ymax <- max(c(inc.scan.sex.int[[i]][,1]))*1.05
    }
    plot(inc.scan.sex.int[[i]], map = map, col = "red", 
        main = names(inc.scan.sex.int)[i], ylim = c(0, ymax))
    if(run_permutations){
        abline(h = fdr_summaries_incidence_sex_int[i,1:2], lty = 1:2, col = "red")
    }
    plot(inc.scan.sex.add[[i]], map = map, add = TRUE)
    if(run_permutations){
        abline(h = fdr_summaries_incidence_sex_add[i,1:2], lty = 1:2, col = "darkblue")
    }

    diff.scan <- inc.scan.sex.int[[i]] - inc.scan.sex.add[[i]]
    plot(diff.scan, map = map, main = "Interactive - Additive")
    if(run_permutations){
        int.p.dist <- -log10(incidence.sex.add.perm[[i]]$min_p)
        add.p.dist <- -log10(incidence.sex.int.perm[[i]]$min_p)
        mean.diff <- max(int.p.dist) - max(add.p.dist)
        abline(h = mean.diff)
    }

    cat("\n\n")
}


#dev.off()
```

## Comparing Scans

There is a question as to whther the scans of similar traits 
in these conditions are sufficiently similar. EAE and 
Classical incidence are correlated in terms of phenotype, 
so their mapping should be similar. 

The following plot shows a heatmap of the correlations between
the incidence phenotypes.

```{r trait_similarity, fig.width = 6, fig.height = 6}
pheatmap(cor(inc.by.sex), display_numbers = TRUE, main = "Incidince Trait Correlations")
```

The following heatmap shows the correlations between
the LOD traces. EAE and Classical are clustered in the LOD traces.

```{r lod_cor, fig.width = 8, fig.height = 8}

overall.lod.mat <- sapply(inc.scan.overall, function(x) x[,1])
colnames(overall.lod.mat) <- paste0(colnames(overall.lod.mat), "_overall")
sex.add.lod.mat <- sapply(inc.scan.sex.add, function(x) x[,1])
colnames(sex.add.lod.mat) <- paste0(colnames(sex.add.lod.mat), "_additive")
sex.int.lod.mat <- sapply(inc.scan.sex.int, function(x) x[,1])
colnames(sex.int.lod.mat) <- paste0(colnames(sex.int.lod.mat), "_interactive")

full.mat <- cbind(overall.lod.mat, sex.add.lod.mat, sex.int.lod.mat)
pheatmap(cor(full.mat))

```

```{r compare_avg_ind, eval = FALSE}
plot(cds.scans[[1]][,1], cds.avg.scans.sex.add[[1]][,1])
```