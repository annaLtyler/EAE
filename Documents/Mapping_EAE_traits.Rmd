---
title: "EAE"
author: Anna L Tyler
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: hide
    collapsed: no
    toc: yes
    toc_float: yes
bibliography: eae.bib
---

## Introduction
The purpose of this workflow is to start getting into data 
sent by Dimitry Krementsov and his graduate studen Emily Holt 
at UVM.

They are interested in the genetics of multiple sclerosis (MS).
The mouse model of MS is called [experimental autoimmune 
enchephalomyelitis (EAE)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3229753/).
In this model, mice are injected with CNS antigens which cause
development of autoimmunity. 

The Krementsov lab is inducing EAE in a panel of CC mice 
to investigate the effect of genetic backgroud on this model.
So far they have identified multiple types of EAE that mirror
the human experience better than the standard model. Whereas
the classic mouse model displays a progressive form of ascending
paralysis, the diverse model has relapsing remitting patterns
of disease, as well as axial-rotory (AR) EAE. These patterns are
also seen in humans, but the genetics of the heterogeneity of 
MS in humans has not been well studied.

In this study, we will try to map genetic variants that 
are associated with subtypes of EAE. We will also use TRiAGE
to prioritize genes within the mapped loci.

## Collecting and Processing Data

From the Excel file that Emily sent, I saved the CDS_Individuals
tab as a csv file. I deleted the header material and an empty row.
I also converted all strings "C57BL/6" to "C57BL6" to match the 
other B6 labels.

I also copied the Incidence tab to three files and deleted the 
line without entries. The files are:

* incidence_female.txt - incidence calculations for all females of each strain
* incidence_male.txt - incidence calculations for all males of each strain
* incidence_strain.txt - incidence calculations for each strain including both sexes

```{r get_arguments}
rm(list = ls())
args <- commandArgs(trailingOnly=T)

b6_correction <- as.logical(args[1]) #Use B6 score to do batch correction
batch_as_covar <- as.logical(args[2]) #use batch as a covariate
rank_norm <- as.logical(args[3]) #whether to rank Z normalize adjusted scores.

#===============================================================
#hard code the final decisions on corrections and normalizations
#set final_param to FALSE to use the arguments again
#===============================================================
final_param = TRUE

if(final_param){
    b6_correction <- FALSE
    batch_as_covar <- TRUE
    rank_norm <- TRUE
}
#===============================================================


if(is.na(b6_correction) || length(b6_correction) == 0){
b6_correction = FALSE; batch_as_covar = FALSE; rank_norm = FALSE
}

if(b6_correction && batch_as_covar){stop("Set either b6_correction or batch_as_covar to TRUE, not both.")}

alpha <- c(0.15, 0.2)
```

```{r load_code}
library(here)

all.fun <- list.files(here("Code"), full.names = TRUE, pattern = ".R")
for(i in 1:length(all.fun)){source(all.fun[i])}

overwrite_previous <- FALSE
add_founder_genotypes <- FALSE
remove_strains <- NULL
#remove_strains <- c("CC051", "CC059") #closely related
#remove_strains <- c("CC051") #pick one of them to keep

cc.color.scheme = "original"
#cc.color.scheme = "new"

exclude.zeros = FALSE #if true, we exclude animals with a CDS of 0
disease.thresh = 0 #maximum disease score considered disease-free

cds.file.date = "November_2023" #date for CDS csv file to use in format month_year
inc.file.date = "November_2023" #date for incidence csv files to use in format month_year

nperm = 10

if(nperm > 0){
    run_permutations <- TRUE
}else{
    run_permutations <- FALSE
}
```

## Parameters

```{r param_text}
if(add_founder_genotypes){
    founders.included = "yes"
}else{
    founders.included = "no"
}

if(length(remove_strains) > 0){
    strains.removed <- paste(remove_strains, collapse = ", ")
}else{
    strains.removed = "none"
}

if(!exclude.zeros){
    zero.text <- "Zeros are included in CDS"
    zero.treatment <- "included with"
}else{
    zero.text <- paste("Animals with scores of", disease.thresh, "and below are excluded from CDS.")
    zero.treatment <- "excluded from"
}

if(b6_correction){
    correction.text <- "Batch corrections were made using B6 CDS."
    correction.label <- "B6-batch"
}
if(batch_as_covar){
    correction.text <- "Batch corrections were done using batch as a covariate."
    correction.label <- "covar-batch"
}
if(!b6_correction && !batch_as_covar){
    correction.text <- "No batch corrections were done."
    correction.label <- "no-batch"
}

if(rank_norm){
    norm.text <- "Rank Z normalization was performed."
    norm.label <- "rank-norm"
}else{
    norm.text <- "Rank Z normalization was not performed."
    norm.label <- "no-norm"
}

file.label <- paste(correction.label, norm.label, sep = "_")
```

The parameters for this run are as follows:

* Founders included: `r founders.included`

* CC Strains removed: `r strains.removed`

* Treatment of zeros: `r zero.text`

* Batch correction: `r correction.text`

* Normalization: `r norm.text`

```{r results_dir}
results.dir <- here("Results", paste("Zeros", strsplit(zero.treatment, " ")[[1]][1], file.label, sep = "_"))
if(!file.exists(results.dir)){dir.create(results.dir)}
```

```{r load_libraries, warning = FALSE}
all.packages <- c("pheatmap", "qtl2", "ggplot2", "abind", "igraph", "knitr", "parallel",
    "stringr")
load_libraries(all.packages)
cores = detectCores()-1
```

Read in phenotype data.

```{r load_data}
if(cc.color.scheme == "original"){
    strain.colors <- CCorigcolors
}else{
    strain.colors <- CCcolors
}

cds <- read.csv(here("Data", paste0("CDS_", cds.file.date, ".csv")), strip.white = TRUE)
incidence.files <- get.files(path = here("Data"), want = c(inc.file.date, "incidence"), 
    full.names = TRUE)
incidence <- lapply(incidence.files, function(x) as.matrix(read.delim(x, row.names = 1, strip.white = TRUE)))
names(incidence) <- gsub(".txt", "", basename(incidence.files))

```

This run uses the CDS file from `r gsub("_", " ", cds.file.date)`.

And the incidence files from `r gsub("_", " ", inc.file.date)`.

```{r batches}
num.cds <- as.matrix(cds[,c("Classical.CDS", "AR.CDS", "Global.CDS")])
rownames(num.cds) <- cds[,"ID"]
#set all scores equal to or lower than the disease threshold
#to zero
if(exclude.zeros){
    num.cds[which(num.cds <= disease.thresh)] <- 0
}

factor.cds <- as.matrix(cds[,c("Strain", "Sex")])
u_batch <- unique(cds[,"EXP"])

#remove animals in batch 170 - these were validation, not part of the original experiment
to.remove = "X170" 
keep.batch <- which(u_batch != "X170")
u_batch <- u_batch[keep.batch]

keep.idx <- which(cds[,"EXP"] != "X170")
cds <- cds[keep.idx,]
num.cds <- num.cds[keep.idx,]
factor.cds <- factor.cds[keep.idx,]

batch.mat <- matrix(0, nrow = nrow(cds), ncol = length(u_batch))
colnames(batch.mat) <- u_batch
for(b in 1:ncol(batch.mat)){
    batch.mat[which(cds[,"EXP"] == u_batch[b]),b] <- 1
}
cds.covar <- as.matrix(cbind(batch.mat, cds[,"Age.at.D0",drop=FALSE]))

pheno.strains <- cds[,"Strain"]
eae.strains <- unique(pheno.strains)
```

## Samples by strain

The following heatmap shows how many individuals are in 
each strain by sex combination.

```{r sample_counts, fig.width = 8, fig.height = 1.5}
count.table <- table(cds[,c("Sex", "Strain")])
strain.order <- c(3:ncol(count.table), 1,2)
par(mar = c(1,4,4,2))
imageWithText(count.table[,strain.order], use.pheatmap.colors = TRUE, 
    col.text.shift = -1.4, row.text.shift = -2, col.text.adj = 0,
    col.text.cex = 0.7, cex = 0.8, row.text.adj = 0.5)
```

## CDS Distribution {.tabset .tabset-fade .tabset-pills}

Each day of the study, each mouse is given a disease CDS 
score between 0 and 5, with lower numbers indicating less 
disease. The cumulative disease score (CDS) for a given mouse
is the sum of these scores over the course of the study.

The distributions of three scores are shown below. Classical
is the classical presentation of paralysis used in the field.
AR (axial rotary) scores an alternate form of paralysis.
Global is the sum of the Classical and AR scores and gives
an overall score of disease regardless of type. 

```{r zeros, fig.width = 8, fig.height = 8}
par(mfrow = c(2,2))
for(i in 1:ncol(num.cds)){
    hist(num.cds[,i], breaks = 50, main = colnames(num.cds)[i], 
    xlab = colnames(num.cds)[i])
}
```

There are many mice that never display measurable symptoms
and have cumulative disease scores of 0. This kind of floor
effect causes problems with statistical tests that assume
a normal distribution.

If exclude.zeros is set to TRUE, these 0 values will be
excluded from CDS mapping.

In this analysis `r zero.text`.

The plots below show the CDS distribution by strain.

```{r cds, results = "asis", fig.width = 10, fig.height = 5}

plot_cds_by_strain <- function(scores, strain.labels, exclude.zeros = TRUE,
    ymin = NULL, ymax = NULL, plot.label = ""){
    
    u_strain <- unique(strain.labels)
    strain.idx <- lapply(u_strain, function(x) which(strain.labels == x))

    if(exclude.zeros){
        nonzero.idx <- which(scores != 0)
    }else{
        nonzero.idx <- 1:length(scores)
    }
    strain.cds <- lapply(strain.idx, function(x) scores[intersect(nonzero.idx, x)])
    names(strain.cds) <- u_strain
    strain.order <- order(sapply(strain.cds, mean))

    if(is.null(ymax)){ymax = max(scores, na.rm = TRUE)}
    if(is.null(ymin)){
        ymin = min(scores, na.rm = TRUE)
        #if(ymin > 0){ymin <- 0}
    }

    #quartz(width = 10, height = 5)
    layout(matrix(c(1,2), ncol = 2), width = c(1, 0.5))
    par(mar = c(4,4,4,0))
    stripchart(strain.cds[strain.order], vertical = TRUE, pch = 16, 
        col = "gray", method = "jitter", las = 2, ylim = c(ymin, ymax),
        main = paste(plot.label, "cds"), ylab = "CDS")
    a <- hist(unlist(strain.cds), plot = FALSE)
    par(mar = c(4,0,4,2))
    plot.new()
    plot.window(xlim = c(0, max(a$counts)), ylim = c(ymin, ymax))
    segments(x0 = rep(0, length(a$counts)), x1 = a$counts, y0 = a$mids, 
        lwd = 10, col = "gray")
    #text(x = a$counts+2, y = a$mids, labels = a$counts, adj = 0, cex = 0.7)
    mtext("Individual Counts", side = 3)
    axis(1)

    invisible(strain.cds)
}

for(cd in 1:ncol(num.cds)){
    cat("###", colnames(num.cds)[cd], "\n")
    temp.vals <- plot_cds_by_strain(scores = num.cds[,cd], 
        strain.labels = factor.cds[,"Strain"], exclude.zeros = exclude.zeros,
        ymax = max(num.cds), plot.label = colnames(num.cds)[cd])
    cat("\n\n")
}
```

## Batch Effects

The individuals were run in multiple batches, which can 
cause systematic biases in the data. We need to correct
any batch effects that we find before we map.

The following heatmap shows how the different 
strains and sexes were represented in different 
batches. The males and females are shown separately.

```{r batch_assortment, fig.width = 5, fig.height = 7}
batch.list <- vector(mode = "list", length = length(u_batch))
for(b in 1:length(u_batch)){
    batch.idx <- which(cds.covar[,b] == 1)
    batch.mat <- matrix(0, nrow = length(eae.strains), ncol = 2)
    rownames(batch.mat) <- eae.strains
    batch.table <- table(data.frame(factor.cds[batch.idx,]))
    batch.mat[match(rownames(batch.table), eae.strains),] <- batch.table
    colnames(batch.mat) <- paste(colnames(cds.covar)[b], colnames(batch.table), sep = "_")
    batch.list[[b]] <- batch.mat
}
all.batch.counts <- Reduce("cbind", batch.list)
imageWithText(all.batch.counts, use.pheatmap.colors = TRUE, col.text.shift = -38.5,
col.text.rotation = 45, col.text.adj = 0, cex = 0.7)
```

The following boxplots show the batch values for the B6 
animals. These show that the batches had an increase in 
CDS across the batches.

```{r b6_batch, fig.width = 8, fig.height = 8, eval = FALSE}
b6.idx <- which(factor.cds[,1] == "C57BL6")
if(exclude.zeros){
    nonzero.idx <- lapply(1:ncol(num.cds), function(x) which(num.cds[,x] != 0))
}else{
    nonzero.idx <- lapply(1:ncol(num.cds), function(x) 1:nrow(num.cds))
}
b6.batch.idx <- apply(cds.covar[,1:(ncol(cds.covar)-1)], 2, 
    function(x) intersect(which(x == 1), b6.idx))

par(mfrow = c(2,2))
b6.by.batch <- vector(mode = "list", length = ncol(num.cds))
names(b6.by.batch) <- colnames(num.cds)
for(cd in 1:ncol(num.cds)){
    #get batch values for this CDS
    vals.by.batch <- lapply(1:length(b6.batch.idx), 
        function(x) num.cds[intersect(b6.batch.idx[[x]], nonzero.idx[[cd]]),cd])
    names(vals.by.batch) <- u_batch
    b6.by.batch[[cd]] <- vals.by.batch
    boxplot(b6.by.batch[[cd]], main = colnames(num.cds)[cd])    
}

```


### Batch correction procedure

The B6 batch correction procedure is as follows:

1. Calculate the overall mean CDS for B6 mice 
    across the entire experiment
2. Calculate the mean CDS B6 mice in each batch.
3. Adjust all mice in each batch based on the
    difference in means in the B6. Subtract off 
    the mean deviation, and divide by the standard
    deviation.
4. Male and female B6 mice do not have a sex 
    difference in CDS, and adjusting by the 
    two sexes separately could inadvertently 
    introduce a sex effect into the other strains,
    so we use overall means rather than sex-specific 
    means.

The batch correction procedure using batch as a covariate is as follows:

1. Create a binary matrix indicating whether each individual
    was run in each batch (1) or not (0).
2. Regress this matrix out of the CDS matrix.


### Remove batch effects {.tabset .tabset-fade .tabset-pills}

```{r adj_cds}
#only correct Classical and Global
#change these indices to change which
#traits are adjusted for batch effects
cds.idx <- c(1,2,3) 
```

Adjust for batch. We adjusted the following traits for batch effects:
`r cat(colnames(num.cds)[cds.idx], sep = "\n")`

```{r no_adj}
adj.cds <- num.cds 
```

```{r adj_batch_covar}
if(batch_as_covar){
    adj.cds <- adjust(num.cds, cds.covar[,1:ncol(cds.covar)-1])
}
```

```{r mean_sd}

if(b6_correction){
    batch.mean <- sapply(b6.by.batch, function(x) sapply(x, mean))
    batch.sd <- sapply(b6.by.batch, function(x) sapply(x, sd))
    batch.sd[which(is.na(batch.sd))] <- 1

    #for each batch
    for(b in c(1:(ncol(cds.covar)-1))){
        batch.idx <- which(cds.covar[,b] == 1)
        for(j in cds.idx){ #only correct classical and global
            if(exclude.zeros){
                    nonzero.idx <- which(num.cds[,j] != 0)
                }else{
                    nonzero.idx <- 1:nrow(num.cds)
                }
            adj.idx <- intersect(batch.idx, nonzero.idx)
            adj.cds[adj.idx,j] <- (num.cds[adj.idx,j] - batch.mean[b,j])/batch.sd[b,j]
        }
    }
    
}
```


### Age at D0 {.tabset .tabset-fade .tabset-pills}

Another one of our covariates is Age.at.D0.

The following boxplot shows that age varies significantly 
by batch.

```{r age_by_batch}
age <- cds.covar[,ncol(cds.covar)]
age.by.batch <- lapply(1:(ncol(cds.covar)-1), function(x) age[which(cds.covar[,x] == 1)])
p.val <- aov.by.list(age.by.batch)$"Pr(>F)"[1]

boxplot(age.by.batch, main = paste("Age at D0 by batch\n", "p =", signif(p.val, 2)))
stripchart(age.by.batch, vertical = TRUE, method = "jitter", pch = 16, 
    col = "#756bb1", add = TRUE)
```

The following plots show the relationship between Age.at.D0
and each CDS after adjusting for batch.

```{r age_at_day0, results = "asis", fig.width = 8, fig.height = 8}

u_age <- unique(cds.covar[,"Age.at.D0"])
age.idx <- lapply(u_age, function(x) which(cds.covar[,"Age.at.D0"] == x))
cds.by.age <- lapply(age.idx, function(x) adj.cds[x,,drop=FALSE])

par(mfrow = c(2,2))
for(i in 1:3){
    just.one <- lapply(cds.by.age, function(x) x[,i])
    x.vals <- lapply(1:length(just.one), function(x) rep(u_age[x], length(just.one[[x]])))
    x <- unlist(x.vals)
    y <- unlist(just.one)
    if(exclude.zeros){
        nonzero.idx <- which(y != 0)
    }else{
        nonzero.idx <- 1:length(y)
    }

    plot.with.model(x[nonzero.idx], y[nonzero.idx], xlab = "Age at D0", 
        ylab = colnames(num.cds)[i], main = colnames(num.cds)[i])
}
```


```{r adjust_age, eval = FALSE}
#adjust for age
for(i in 1:ncol(adj.cds)){
    if(exclude.zeros){
        nonzero.idx <- which(num.cds[,i] != 0)
    }else{
        nonzero.idx <- 1:nrow(num.cds)
    }
    adj.cds[nonzero.idx,i] <- adjust(adj.cds[nonzero.idx,i,drop=FALSE], 
        cds.covar[nonzero.idx,"Age.at.D0",drop=FALSE])
}
```

```{r write_adj}
#write out the results of whatever adjustments we have done
write.table(adj.cds, file.path(results.dir, "Adj_CDS.csv"), sep = ",", quote = FALSE)
```

Rank Z normalize the CDS scores if this is specified.

```{r no_norm}
norm.cds <- adj.cds
colnames(norm.cds) <- gsub(".CDS", "", colnames(norm.cds)) #take off CDS in labels, to save room in plots
```

```{r norm}
if(rank_norm){
    for(i in 1:ncol(norm.cds)){
        if(exclude.zeros){
            nonzero.idx <- which(num.cds[,i] != 0)
        }else{
            nonzero.idx <- 1:nrow(num.cds)
        }
        norm.cds[nonzero.idx,i] <- rankZ(adj.cds[nonzero.idx,i])
    }
}
colnames(norm.cds) <- gsub(".CDS", "", colnames(norm.cds)) #take off CDS, to save room in plots

#write out normzliaed values
write.table(norm.cds, file.path(results.dir, "Norm_CDS.csv"), sep = ",", quote = FALSE)

```

### Normalized Scores {.tabset .tabset-fade .tabset-pills}

The following plots show the distribution of each 
disease score after adjustments and normalization.

```{r norm_dist, fig.width = 10, fig.height = 5, results = "asis"}
#ymin = min(norm.cds);ymax = max(norm.cds) #all on same axes
ymin = NULL; ymax = NULL #all on independend axes
for(cd in 1:ncol(norm.cds)){
    cat("####", colnames(norm.cds)[cd], "\n")
    plot_cds_by_strain(scores = norm.cds[,cd], 
        strain.labels = factor.cds[,"Strain"], exclude.zeros = exclude.zeros,
        ymin = ymin, ymax = ymax, plot.label = colnames(num.cds)[cd])
    cat("\n\n")
}

```

## CC genotypes

I downloaded the CC genotypes from the UNC website:
http://csbio.unc.edu/CCstatus/CCGenomes/#genotypes

I downloaded the Most Recent Common Ancestor file. 
This has marker names from the mega muga. I downloaded the
mega muga marker map from the Jackson Laboratory 
[resource for CC/DO mice](https://www.jax.org/research-and-faculty/genetic-diversity-initiative/tools-data/diversity-outbred-reference-data)

```{r get_CC_genotypes, warning = FALSE}

cc.geno <- readRDS(here("Data", "MRCA10_modelprobs_trim.rds"))
marker.info.file <- here("Data", "mouse", "mm_uwisc_v1.csv")
marker.info <- read.csv(marker.info.file)

#convert the map and the genoprobs into a qtl2 object
cross_obj <- array2qtl2(cc.geno, marker.info, chr = c(1:19, "X"), chr.col = "chr", 
    pos.col = "bp_mm10", crosstype = "risib8")

cc.genoprobs <- cross_obj$genoprobs
map <- cross_obj$map

K <- calc_kinship(cc.genoprobs, "loco")

```


```{r old, eval = FALSE}

map.file <- here("Data", "map.RDS")
new.geno.file <- here("Data", "genoprobs.RDS")
k.file <- here("Data", "kinship_loco.RDS")

if(!file.exists(map.file)){
    file <- paste0("https://raw.githubusercontent.com/rqtl/", "qtl2data/master/CC/cc.zip")
    cc <- read_cross2(file)
    map <- map
    saveRDS(map, map.file)
    
    cc.official <- rownames(cc$geno[[1]])
    cc.alias <- sapply(strsplit(cc.official, "/"), function(x) x[1])
    write.table(cbind(cc.official, cc.alias), here("Data", "CC_names.txt"), sep = "\t", 
        quote = FALSE, row.names = FALSE, col.names = FALSE)
    
    cc.genoprobs <- calc_genoprob(cc, cores = cores)    
    new.genoprobs <- cc.genoprobs

    #add strains 83 and 84 to the genoprobs 
    new.strains <- c("CC083", "CC084")
    new.strain.idx <- match(new.strains, rownames(cc.geno))
    for(i in 1:length(cc.genoprobs)){
        chr.markers <- dimnames(cc.genoprobs[[i]])[[3]]
        common.markers <- intersect(chr.markers, dimnames(cc.geno)[[3]])
        orig.idx <- match(common.markers, dimnames(cc.genoprobs[[i]])[[3]])
        new.idx <- match(common.markers, dimnames(cc.geno)[[3]])
        new.chr <- abind(cc.genoprobs[[i]][,,orig.idx], cc.geno[new.strain.idx,,new.idx], along = 1)
        new.genoprobs[[i]] <- new.chr
    }
    saveRDS(new.genoprobs, new.geno.file)

    #overwrite the original objecct
    cc.genoprobs <- new.genoprobs

    K <- calc_kinship(new.genoprobs, "loco")
    saveRDS(K, k.file)
}else{
    map <- readRDS(map.file)
    cc.genoprobs <- readRDS(new.geno.file)
    K <- readRDS(k.file)
}

```

If specified, add genoptypes for 129, NOD, and B6, so we 
can use them in mapping.

```{r add_other_strains}
if(add_founder_genotypes){
    founder_fun <- function(strain.name){
        founder.genotypes <- rep(0, length(strain.colors))
        founder.idx <- which(names(strain.colors) == strain.name)
        founder.genotypes[founder.idx] <- 1
        return(founder.genotypes)
    }

    strain.129 <- founder_fun("129")
    strain.b6 <- founder_fun("B6")
    strain.nod <- founder_fun("NOD")

    mapping.genoprobs  <- cc.genoprobs
    for(i in 1:length(cc.genoprobs)){
        ind.129 <- matrix(strain.129, nrow = ncol(cc.genoprobs[[i]]), 
            ncol = dim(cc.genoprobs[[i]])[3])
        ind.b6 <- matrix(strain.b6, nrow = ncol(cc.genoprobs[[i]]), 
            ncol = dim(cc.genoprobs[[i]])[3])
        ind.nod <- matrix(strain.nod, nrow = ncol(cc.genoprobs[[i]]), 
            ncol = dim(cc.genoprobs[[i]])[3])
        new.chr <- abind(cc.genoprobs[[i]], ind.129, ind.b6, ind.nod, along = 1)
        rownames(new.chr)[tail(1:length(rownames(new.chr)), 3)] <- c("129", "C57BL6", "NOD")
        mapping.genoprobs[[i]] <- new.chr
    }

    #recalculate K for the new genoprobs.
    mapping.K <- calc_kinship(mapping.genoprobs, "loco")
    mapping.strains <- eae.strains
}else{
    mapping.genoprobs <- cc.genoprobs
    mapping.K <- K
    mapping.strains <- eae.strains[grep("CC", eae.strains)]
}
```

```{r geno_query, eval = FALSE}

chr_col <- function(pos.col, max.alleles){
    full.col <- rep(NA, max.alleles)
    if(length(pos.col) == 1){     
        buffer <- max.alleles - 2
        full.col <- c(rep(pos.col, 2), rep("white", buffer))
    }else{
        buffer <- max.alleles - length(pos.col)
        full.col <- c(pos.col, rep("white", buffer))
    }
    return(full.col)
}

hets <- lapply(cc.genoprobs, function(x) sapply(apply(x, 3, function(y) which(round(y, 2) == 0.5)), length))
other.prob <- lapply(cc.genoprobs, function(x) sort(unique(unlist(apply(x, 3, function(y) unique(as.vector(round(y, 2))))))))
boxplot(other.prob)

h2.chr <- 17
#cc.chr <- cc.genoprobs[[h2.chr]]
strain.idx <- sapply(mapping.strains, function(x) grep(x, rownames(mapping.genoprobs[[1]])))
cc.chr <- mapping.genoprobs[[h2.chr]][strain.idx,,]
marker.pos <- map[[h2.chr]][match(dimnames(cc.chr)[[3]], names(map[[h2.chr]]))]
marker.bounds <- get_plot_bounds(1, max(marker.pos), scale.factor = 0.1)
#pdf("~/Desktop/CC_geno.pdf", width = 3, height = 8)
all.col <- vector(mode = "list", length = nrow(cc.chr)*2)
idx <- 1
for(i in 1:nrow(cc.chr)){
    
    ind.geno <- round(cc.chr[i,,], 2) #one mouse's genotype for the chromosome
    ind.col <- apply(ind.geno, 2, function(x) strain.colors[which(x > 0)])    
    num.each <- sapply(ind.col, length)
    num.chr <- max(num.each)
    max.alleles <- max(2, num.chr)
    mat <- t(sapply(ind.col, function(x) chr_col(x, max.alleles)))
    rot.mat <- rotate.mat(rotate.mat(mat))
    #rot.mat <- mat
    
    #layout(matrix(c(1,2), ncol = 2), widths = c(0.7, 1))
    #par(mar = c(4,4,4,0))
    #plot(c(1,dim(rot.mat)[2]), c(1, marker.bounds[2]), type = "n", axes = FALSE, xlab = "", ylab = "")
    #axis(2, line = -2)
    #mtext("Chromosome Position (Mb)", side = 2, line = 0.5)
    #par(mar = c(4,0,4,4))
    #plot(c(1, dim(rot.mat)[2]), c(1, dim(rot.mat)[1]), type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(0.7, dim(mat)[2]+0.2), ylim = c(0.7, dim(mat)[1]+0.2), bg = "transparent")
    #rasterImage(rot.mat, xleft = 0.5, ybottom = 0.5, xright = dim(mat)[2]+0.5, ytop = dim(mat)[1]+0.5, interpolate = FALSE, bg = "transparent")
    #mtext(rownames(cc.chr)[i], side = 3)
    
    all.col[[idx]] <- rot.mat
    idx = idx + 1
    spacer.mat  <- matrix("white", nrow = dim(rot.mat)[1], ncol = 4)
    all.col[[idx]] <- spacer.mat
    idx = idx + 1
}

contact.sheet <- Reduce("cbind", all.col)
png(file.path("~/Desktop", paste0("CC_Chr", h2.chr, "_geno.png")), width = ncol(contact.sheet)/4, height = 8, units = "in", res = 300)
layout(matrix(c(1,2), ncol = 2), widths = c(0.03, 1))
par(mar = c(4,4,4,0))
plot(c(1,dim(mat)[2]), c(1, marker.bounds[2]), type = "n", axes = FALSE, xlab = "", ylab = "")
axis(2, line = -4)
mtext("Chromosome Position (Mb)", side = 2, line = 0.5)
par(mar = c(4,0,4,4))
plot(c(1, dim(contact.sheet)[2]), c(1, dim(contact.sheet)[1]), type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(0.7, dim(contact.sheet)[2]+0.2), ylim = c(0.7, dim(contact.sheet)[1]+0.2), bg = "transparent")
rasterImage(contact.sheet, xleft = 0.5, ybottom = 0.5, xright = dim(contact.sheet)[2]+0.5, ytop = dim(contact.sheet)[1]+0.5, interpolate = FALSE, bg = "transparent")
plot.dim <- par("usr")
chr.coord <- which(contact.sheet[1,] != "white")
consec.coord <- consec.pairs(chr.coord)
consec.dist <- consec.coord[,2] - consec.coord[,1]
label.coord <- chr.coord[which(consec.dist == 1)]
#label.coord <- segment.region(plot.dim[1], plot.dim[2], nrow(cc.chr))
text(x = label.coord+0.5, y = rep(nrow(contact.sheet)*1.02, nrow(cc.chr)), labels = sapply(strsplit(rownames(cc.chr), "/", fixed = TRUE), function(x) x[1]))
dev.off()

#dev.off()
```

## Allele Frequencies {.tabset .tabset-fade .tabset-pills}

The following plots show the frequencies of each founder 
allele across each chromosome. Regions in which the allele
frequencies are imbalanced may not be good for mapping.

```{r allele_freq, results = "asis", fig.width = 8, fig.height = 4}
allele_freq <- lapply(mapping.genoprobs, function(x) apply(x, 3, colMeans))
for(ch in 1:length(allele_freq)){
    cat("### Chr", names(map)[[ch]], "\n")
    layout(matrix(c(1,2), nrow = 1), widths = c(1,0.3))
    par(mar = c(4,4,4,0))
    plot.new()
    plot.window(xlim = c(0, max(map[[ch]])), ylim = c(0,0.4))
    for(a in 1:nrow(allele_freq[[ch]])){
        points(map[[ch]][dimnames(mapping.genoprobs[[ch]])[[3]]], 
        allele_freq[[ch]][a,], col = strain.colors[a], type = "l", lwd = 2)
    }
    abline(h = 0)
    axis(1)
    axis(2)
    mtext(paste("Chr", names(map)[[ch]]))
    plot.new()
    plot.window(xlim = c(0,1), ylim = c(0,1))
    par(mar = c(4,0,4,0))
    legend(x = 0, y = 1, lty = 1, col = strain.colors, legend = names(strain.colors), 
        horiz = FALSE, bg = "white", lwd = 2, adj = 0)
    cat("\n\n")
}
```

## Sex Effects Plotted by Individual {.tabset .tabset-fade .tabset-pills}

The following plots show the trait distributions for each
strain. Each plot is ordered by overall strain mean.

For each strain, the dots are split and colored by sex. 
Each point represents one mouse. The horizontal line
shows the mean value for that sex. This helps show
where there might be sex effects in individual strains.


```{r trait_fun}
#This function puts the given trait into a list based
#on strain and plots it if desired.
trait_list <- function(strain.tables, trait.name, exclude.zeros = TRUE, 
    col.by = NULL, plot.results = TRUE){

    if(length(col.by) == 0){col.by = rep("gray", sum(sapply(strain.tables, nrow)))}
    if(length(col.by) == 1){col.by = rep(col.by, sum(sapply(strain.tables, nrow)))}
    u_cols <- unique(col.by)

    if(length(u_cols) > 1){
        col.seg <- segment.region(-0.15, 0.15, length(u_cols), "ends")
    }else{
        col.seg <- 0
    }

    strain.trait <- lapply(strain.tables, function(x) x[,trait.name])
    names(strain.trait) <- names(strain.tables)

    if(exclude.zeros){
        #remove 0, to do CDS only
        nonzero.idx <- which(unlist(strain.trait) != 0) #find indices to remove from other variables
        strain.trait <- lapply(strain.trait, function(x) x[which(x != 0)]) #remove zeros
    }else{
        nonzero.idx <- 1:length(unlist(strain.trait))
    }
    col.by <- col.by[nonzero.idx]

    trait.mean <- sapply(strain.trait, mean)
    trait.order <- order(trait.mean)

    plot.idx <- unlist(lapply(1:length(strain.trait), function(x) rep(x, length(strain.trait[[x]]))))

    if(plot.results){
        ymin <- min(unlist(strain.trait), na.rm = TRUE)
        ymax <- max(unlist(strain.trait), na.rm = TRUE)

        plot.new()
        plot.window(xlim = c(1,length(strain.tables)), ylim = c(ymin, ymax))
        x <- 1
        for(i in trait.order){
            #plot the colors separately so we can see them better
            for(j in 1:length(u_cols)){
                ind.idx <- which(plot.idx == i)
                col.idx <- which(col.by[ind.idx] == u_cols[j])
                points(rep(x+col.seg[j], length(col.idx)), 
                    strain.trait[[i]][col.idx], col = u_cols[j], pch = 16)
                points(x+col.seg[j], 
                    mean(strain.trait[[i]][col.idx]), col = u_cols[j], pch = "-", cex = 2)
                #segments(x0 = x+col.seg[j], y0 = ymin, y1 = ymax, col = u_cols[j])
                segments(x0 = x+0.5, y0 = ymin, y1 = ymax, col = "gray")
            }
            x <- x + 1
        }
        axis(2)
        par(xpd = TRUE)
        text(x = 1:length(strain.trait), y = rep(ymin, length(strain.trait)), 
            labels = names(strain.trait)[trait.order], srt = 90, adj = 1)
        par(xpd = FALSE)
        mtext(trait.name, side = 3, line = 2, font = 2)
        #stripchart(strain.trait[trait.order], vertical = TRUE, pch = 16, method = "jitter", las = 2, main = trait.name, ylab = trait.name)
    }
    return(strain.trait)
}

#This function plots the mean by the col.by argument
#and tests for statistical differences between these
#means. It returns a vector of p values, one for each
#strain.
trait_bars <- function(strain.tables, trait.name, exclude.zeros = TRUE,
    col.by = NULL, plot.results = TRUE){

    if(length(col.by) == 0){col.by = rep("gray", sum(sapply(strain.tables, nrow)))}
    if(length(col.by) == 1){col.by = rep(col.by, sum(sapply(strain.tables, nrow)))}
    u_cols <- unique(col.by)
    col.seg <- segment.region(-0.15, 0.15, length(u_cols), "ends")

    strain.trait <- lapply(strain.tables, function(x) x[,trait.name])
    names(strain.trait) <- names(strain.tables)

    if(exclude.zeros){
        #remove 0, to do CDS only
        nonzero.idx <- which(unlist(strain.trait) != 0) #find indices to remove from other variables
        strain.trait <- lapply(strain.trait, function(x) x[which(x != 0)]) #remove zeros
    }else{
        nonzero.idx <- 1:length(unlist(strain.trait))
    }
    col.by <- col.by[nonzero.idx]

    trait.mean <- sapply(strain.trait, mean)
    trait.order <- order(trait.mean)

    plot.idx <- unlist(lapply(1:length(strain.trait), function(x) rep(x, length(strain.trait[[x]]))))
    diff.p <- rep(NA, length(strain.tables))
    names(diff.p) <- names(strain.tables)[trait.order]
    
    if(plot.results){
        ymin <- min(unlist(strain.trait), na.rm = TRUE)
        ymax <- max(unlist(strain.trait), na.rm = TRUE)

        plot.new()
        plot.window(xlim = c(1,length(strain.tables)), ylim = c(ymin, ymax))
        x <- 1
        for(i in trait.order){
            #plot the colors separately so we can see them better
            test.diff <- vector(mode = "list", length = length(u_cols))
            for(j in 1:length(u_cols)){
                ind.idx <- which(plot.idx == i)
                col.idx <- which(col.by[ind.idx] == u_cols[j])
                points(x+col.seg[j], 
                    mean(strain.trait[[i]][col.idx]), col = u_cols[j], type = "h",
                    lwd = 3)
                test.diff[[j]] <- strain.trait[[i]][col.idx]
                #segments(x0 = x+col.seg[j], y0 = ymin, y1 = ymax, col = u_cols[j])
                segments(x0 = x+0.5, y0 = ymin, y1 = ymax, col = "gray")
            }
            if(all(sapply(test.diff, length) > 1)){
                test <- aov.by.list(test.diff)
                diff.p[x] <- test[1,"Pr(>F)"]
            }
            x <- x + 1
        }
        axis(2)
        par(xpd = TRUE)
        text(x = 1:length(strain.trait), y = rep(ymin, length(strain.trait)), 
            labels = names(strain.trait)[trait.order], srt = 90, adj = 1)
        par(xpd = FALSE)
        mtext(trait.name, side = 3, line = 2, font = 2)
        abline(h = 0)
        #stripchart(strain.trait[trait.order], vertical = TRUE, pch = 16, method = "jitter", las = 2, main = trait.name, ylab = trait.name)
    }
    return(diff.p)
}
```

```{r trait_dist}
strain.tables <- lapply(mapping.strains, function(x) norm.cds[which(cds[,1] == x),])
strain.factors <- lapply(mapping.strains, function(x) factor.cds[which(cds[,1] == x),])
names(strain.tables) <- names(strain.factors) <- mapping.strains
```

### Classical

```{r dots_classical, fig.width = 10, fig.height = 5}
sex.col <- as.numeric(as.factor(unlist(lapply(strain.factors, function(x) x[,"Sex"]))))

strain.classical <- trait_list(strain.tables, "Classical", col.by = sex.col+2, 
    exclude.zeros = exclude.zeros)
legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
    bg = "white")
```

### AR

```{r dots_ar, fig.width = 10, fig.height = 5}
strain.ar  <- trait_list(strain.tables, "AR", col.by = sex.col+2,
    exclude.zeros = exclude.zeros)
legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
    bg = "white")
```

### Global

```{r dots_global, fig.width = 10, fig.height = 5}
strain.global <- trait_list(strain.tables, "Global",col.by = sex.col+2, 
    exclude.zeros = exclude.zeros)
legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
    bg = "white")
```

## Sex Effects by Strain {.tabset .tabset-fade .tabset-pills}

The following plots distill the above figures to just the 
means for each sex. This makes it easier to see where the
means for the two sexes are different. 

An imbalance of sex effects in the different strains could
lead to strange mapping patterns (I think).

The top plot for each shows the means for each sex and each
strain. The strains are ordered by overall strain mean.

The middle plot shows the -log10 of the p value for each 
difference. The solid line shows the p = 0.05 threshold,
and the dashed line shows the bon ferroni adjust p value
threshold.

The bottom dot plot shows a direct comparison of 
female means vs. male means for each strain and 
each trait. Strains with a large difference between
male and female (90th percentile) are labeled.

Overall there is no difference between the sexes.
However, a few strains have large sex biases. 
For CC044, CC075, and CC072, females tend to have a
larger disease score. For CC042, the males tend to
have a larger disease score.

### Classical

```{r plot_bars_fun}

plot_bars <- function(trait.name, exclude.zeros){
    layout(matrix(c(1,2), ncol = 1), heights = c(1, 0.5))
    par(mar = c(3,4,4,4))
    classical.p <- trait_bars(strain.tables, trait.name, col.by = sex.col+2, 
        exclude.zeros = exclude.zeros)
    legend("topleft", pch = 16, col = unique(sex.col)+2, legend = c("Female", "Male"), 
        bg = "white")
    par(mar = c(4,3.5,0,3.5))
    p.thresh <- c(-log10(0.05), -log10(0.05/length(strain.tables)))
    ymax <- max(c(p.thresh, -log10(classical.p)), na.rm = TRUE)
    ymax <- ceiling(ymax*1)/1
    a <- barplot(-log10(classical.p), las = 2, ylim = c(0, ymax))
    mtext("-log10(p) for sex difference", side = 2, line = 2.5)
    segments(x0 = rep(0, length(p.thresh)), x1 = rep(max(a[,1]), length(p.thresh)), 
        y0 = p.thresh, lty = c(1,2))
    par(xpd = TRUE)
    text(x = max(a[,1]), y = -log10(0.05), labels = "0.05", adj = 0)
    text(x = max(a[,1]), y = -log10(0.05/length(strain.tables)), labels = "corrected", adj = 0)
    par(xpd = FALSE)
}
```

```{r plot_dots}
plot_dots <- function(trait.name, diff.percentile = 90){

    f.vals <- lapply(1:length(strain.factors), function(x) strain.tables[[x]][which(strain.factors[[x]][,"Sex"] == "F"),trait.name])
    m.vals <- lapply(1:length(strain.factors), function(x) strain.tables[[x]][which(strain.factors[[x]][,"Sex"] == "M"),trait.name])

    f.means <- sapply(f.vals, mean)
    m.means <- sapply(m.vals, mean)

    diffs <- abs(f.means - m.means)
    diff.thresh <- get.percentile(diffs, diff.percentile)
    big.diffs <- which(diffs >= diff.thresh)

    plot(f.means, m.means, pch = 16, xlab = "Female Mean", ylab = "Male Mean",
    main = trait.name)
    abline(0,1)
    text(f.means[big.diffs], m.means[big.diffs], labels = names(strain.factors)[big.diffs],
        pos = 2)
    
}
```

```{r bars_classical, fig.width = 10, fig.height = 7}
plot_bars("Classical", exclude.zeros = exclude.zeros)
```

```{r dots_comp_classical}
plot_dots("Classical")
```


### AR

```{r bars_ar, fig.width = 10, fig.height = 7}
plot_bars("AR", exclude.zeros = exclude.zeros)
```

```{r dots_comp_ar}
plot_dots("AR")
```


### Global

```{r bars_global, fig.width = 10, fig.height = 7}
plot_bars("Global", exclude.zeros = exclude.zeros)
```

```{r dots_comp_global}
plot_dots("Global")
```


### Overall Sex Effect

```{r sex_diff, fig.height = 8, fig.width = 8}
#quartz(width = 8, height = 8)
par(mfrow = c(2,2))
for(i in 1:ncol(norm.cds)){
    if(exclude.zeros){
        nonzero.idx <- which(norm.cds[,i] != 0)
    }else{
        nonzero.idx <- 1:nrow(norm.cds)
    }
    model <- lm(norm.cds[nonzero.idx,i]~as.factor(factor.cds[nonzero.idx,"Sex"]))
    f <- summary(model)$fstatistic
    p <- pf(f[1],f[2],f[3],lower.tail=F)
    boxplot(norm.cds[nonzero.idx,i]~as.factor(factor.cds[nonzero.idx,"Sex"]), 
        ylab = colnames(norm.cds)[i],
        main = paste(colnames(norm.cds)[i], "\np =", signif(p, 2)), xlab = "")
}
```

## CDS Trait Correlations

The following plot shows that global CDS
is dominated by classical disease.
It also shows that CDS in classical 
disease and AR are unrelated to each other.

```{r trait_cor, fig.width = 8, fig.height = 8}
trait.pairs <- pair.matrix(1:ncol(norm.cds))
par(mfrow = c(2,2))
for(i in 1:nrow(trait.pairs)){
    trait1 <- trait.pairs[i,1]
    trait2 <- trait.pairs[i,2]
    if(exclude.zeros){
        nonzero.idx <- intersect(which(norm.cds[,trait1] != 0), which(norm.cds[,trait2] != 0))
    }else{
        nonzero.idx <- 1:nrow(norm.cds)
    }
    plot.with.model(norm.cds[nonzero.idx,trait1], norm.cds[nonzero.idx,trait2],
        xlab = colnames(norm.cds)[trait1], ylab = colnames(norm.cds)[trait2],
        main = paste(colnames(norm.cds)[trait1], "vs.", colnames(norm.cds)[trait2]))
}
```

## Map CDS with Individuals

We mapped each CDS across the individual mice. 

```{r methods}
if(add_founder_genotypes){
    methods.line <- "Both CC and founder strains were used for mapping."
}else{
    methods.line <- "We used only CC strains for mapping."
}

if(length(remove_strains) != 0){
    remove.line <- paste("We excluded the following strains:", paste(remove_strains, collapse = ", "))
}else{
    remove.line <- "No CC strains were excluded."
}
```

`r methods.line`
`r remove.line`

For the genoprobs and kinship matrices, we copied
the entries for the individuals in each strain and
used indices for row names.

The LOD traces for each trait are shown below along 
with plots for the FDR results. Significance thresholds
from the permutations are also shown on the LOD traces.

```{r expand_matrices}

if(length(remove_strains) != 0){
    remove.idx <- sapply(remove_strains, function(x) which(mapping.strains == x))
    mapping.strains <- mapping.strains[-remove.idx]
}

pheno.strains <- unlist(sapply(mapping.strains, function(x) pheno.strains[grep(x, pheno.strains)]))

K.idx <- sapply(mapping.strains, function(x) grep(x, rownames(mapping.K[[1]])))
K.num <- sapply(mapping.strains, function(x) length(which(pheno.strains == x)))
expanded.idx <- unlist(lapply(1:length(K.idx), function(x) rep(K.idx[x], K.num[x])))
groups <- names(expanded.idx)

exp.K <- lapply(1:length(mapping.K), function(x) mapping.K[[x]][expanded.idx,expanded.idx])
names(exp.K) <- names(mapping.K)

#create unique row and column names
for(i in 1:length(exp.K)){
    rownames(exp.K[[i]]) <- colnames(exp.K[[i]]) <- 1:length(expanded.idx)
}

expanded.genoprobs <- mapping.genoprobs
for(i in 1:length(expanded.genoprobs)){
    expanded.genoprobs[[i]] <- mapping.genoprobs[[i]][expanded.idx,,]
    rownames(expanded.genoprobs[[i]]) <- 1:length(expanded.idx)
}

#align the phenotypes with the strains
pheno.idx <- which(cds[,1] %in% pheno.strains)

pheno.idx <- which(cds[,1] %in% pheno.strains)
covar <- matrix(as.numeric(as.factor(cds[pheno.idx,"Sex"])), ncol = 1)
rownames(covar) <- 1:length(covar)

#test <- cds[pheno.idx,]

mapping.pheno <- norm.cds[pheno.idx,]
rownames(mapping.pheno) <- 1:length(expanded.idx)

mapping.factors <- factor.cds[pheno.idx,]
mapping.covar <- matrix(as.numeric(as.factor(mapping.factors[,"Sex"])), ncol = 1)
rownames(mapping.covar) <- 1:nrow(mapping.covar)
```

### Heritability

The heritability of CDS is shown below.

```{r herit, fig.width = 5, fig.height = 5}
overall.k.file <- here("Data", "kinship_overall.RDS")
if(!file.exists(overall.k.file) || overwrite_previous){
    overall.K <- calc_kinship(expanded.genoprobs, "overall")
    saveRDS(overall.K, overall.k.file)
}else{
    overall.K <- readRDS(overall.k.file)
}

ind.herit <- rep(NA, ncol(num.cds))
names(ind.herit) <- colnames(num.cds)
for(i in 1:ncol(num.cds)){
    nonzero.idx <- which(mapping.pheno[,i] != 0)
    ind.herit[i] <- est_herit(mapping.pheno[nonzero.idx,i,drop=FALSE], overall.K)
}

barplot_with_num(round(ind.herit, 2), ylab = "Heritability", xlab = "", 
    ylim = c(0, 0.4), text.shift = 0.09, main = "Trait Heritability Estimates")
```

```{r mapping_fun}
#We have run into problems with extremely small variance
#in genotype probabilities leading to large LOD scores.
#round.digs attempts to solve this by rounding all 
#genotype probabilities to the specified number of 
#significant figures. All CC lines should be either 1 or
#0 at every locus, so 2 digits should be sufficient to 
#get any errant heterozygotes, but also squash out very
#small variations
map_pheno <- function(map.geno, map.pheno, map.K, addcovar = NULL,
    intcovar = NULL, groups = NULL, exclude.zeros = TRUE, 
    round.digs = 2,
    results.file = file.path(results.dir, "scan1_results.RDS")){

    if(!file.exists(results.file) || overwrite_previous){

        #round the genotypes so low-variance markers don't lead
        #to large QTL LOD scores
        rounded.geno <- map.geno
        for(chr in 1:length(rounded.geno)){
            rounded.geno[[chr]] <- round(map.geno[[chr]], round.digs)
        }

        pheno.scans <- vector(mode = "list", length = ncol(map.pheno))
        names(pheno.scans) <- colnames(map.pheno)
        for(ph in 1:ncol(map.pheno)){
            if(exclude.zeros){
                nonzero.idx <- which(map.pheno[,ph] != 0)
            }else{
                nonzero.idx <- 1:nrow(map.pheno)
            }

            pheno.scans[[ph]] <- scan1(rounded.geno, map.pheno[nonzero.idx,ph], 
                addcovar = addcovar, intcovar = intcovar, kinship = map.K)
            #plot(pheno.scans[[ph]], map = map)
        }
        saveRDS(pheno.scans, results.file)
    }else{
        pheno.scans <- readRDS(results.file)
    }
    return(pheno.scans)
}


perm_scans <- function(map.geno, map.pheno, map.k, scan1.results, 
    addcovar = NULL, intcovar = NULL, groups = NULL, nperm = nperm, 
    max.exp.lod = 20, n.founders = 8, exclude.zeros = TRUE, 
    results.file = file.path(results.dir, "perm.RDS"), round.digs = 2){

    #permutations for Matt's FDR method (see https://github.com/j-matthew-mahoney/cdf-fdrci.git)
    #right now this does one phenotype at a time, but we can change that later.
    perm.data <- vector(mode = "list", length = ncol(map.pheno))
    nind = nrow(map.pheno)
    #bin possible LOD scores
    breaks = lod2p(seq(max.exp.lod, 0, -0.01), nind = nind, k = n.founders)

    #round the genotypes to get rid of very small variances that
    #lead to large QTL LOD scores
    rounded.geno <- map.geno
    for(chr in 1:length(rounded.geno)){
        rounded.geno[[chr]] <- round(map.geno[[chr]], round.digs)
    }

    if(!file.exists(results.file)){
        for(ph in 1:ncol(map.pheno)){
            if(exclude.zeros){
                nonzero.idx <- which(map.pheno[,ph] != 0)
            }else{
                nonzero.idx <- 1:nrow(map.pheno)
            }
            if(!is.null(groups)){
                null_stats = scan1_groupperm_stats(rounded.geno, 
                    pheno = map.pheno[nonzero.idx,ph,drop=FALSE], 
                    groups = groups[nonzero.idx],
                    kinship = map.k, nperm = nperm, breaks = breaks, 
                    addcovar = addcovar, intcovar = intcovar,
                    scan1_out = scan1.results[[ph]][,1,drop=FALSE], cores = cores)
            }else{
                null_stats = scan1perm_stats(rounded.geno, 
                    pheno = map.pheno[nonzero.idx,ph,drop=FALSE], 
                    kinship = map.k, nperm = nperm, breaks = breaks,
                    addcovar = addcovar, intcovar = intcovar,
                    scan1_out = scan1.results[[ph]][,1,drop=FALSE], cores = cores)
            }
            perm.data[[ph]] <- null_stats
        }
        saveRDS(perm.data, results.file)
    }else{
        perm.data <- readRDS(results.file)
    }
    return(perm.data)
}


plot_fdr_fun <- function(scan.results, perm.results, tab.level = "###"){

    fdr_summaries <- matrix(NA, nrow = length(scan.results), ncol = 5)
    rownames(fdr_summaries) <- names(scan.results)
    for(ph in 1:length(scan.results)){
        cat(tab.level, names(scan.results)[ph], "\n")
        summary_thresholds = fdr_summarize(perm.results[[ph]], fdr_cl = 0.95, 
            geno_sig = alpha, fdr_thresh = c(0.1, 0.2, 0.4), 
            plot = TRUE, quartz = FALSE)

        finite.thresh <- which(is.finite(summary_thresholds))

        maxy <- max(c(scan.results[[ph]][,1], 
            summary_thresholds[finite.thresh], na.rm = TRUE))*1.1
        par(mar = c(4, 4, 4, 8))
        plot(scan.results[[ph]], map = map, main = names(scan.results)[ph], 
            ylim = c(0, maxy))
        abline(h = summary_thresholds)
        plot.dim <- par("usr")
        par(xpd = TRUE)
        text(x = plot.dim[2], y = summary_thresholds[finite.thresh], 
            labels = names(summary_thresholds)[finite.thresh], cex = 0.5, adj = 0)
        par(xpd = FALSE)
        fdr_summaries[ph,] <- summary_thresholds
        cat("\n\n")
    }
    colnames(fdr_summaries) <- names(summary_thresholds)
    invisible(fdr_summaries)
}

select_threshold <- function(scan.results, fdr_summaries){
    for(ph in 1:length(scan.results)){
        finite.thresh <- fdr_summaries[ph,which(is.finite(fdr_summaries[ph,]))]
        peak.tables <- lapply()
    }

}

allele_coef <- function(map.geno, map.pheno, map.k, addcovar = NULL,
    intcovar = NULL, scan.results, lod.threshold, exclude.zeros, 
    chr.lod.file, chr.coef.file, round.digs = 2){

    peak.table <- lapply(1:length(scan.results), 
        function(x) find_peaks(scan.results[[x]], map = map, 
        threshold = lod.threshold[x]))

    #round genotypes to reduce risk of low-variance alleles
    #leading to large QTL LOD scores
    rounded.geno <- map.geno
    for(chr in 1:length(rounded.geno)){
        rounded.geno[[chr]] <- round(map.geno[[chr]], round.digs)
    }

    if(!file.exists(chr.lod.file) || overwrite_previous){
        chr.lod <- chr.coef <- vector(mode = "list", length = nrow(Reduce("rbind", peak.table)))
        idx = 1
        for(ph in 1:length(peak.table)){
            if(nrow(peak.table[[ph]]) != 0){
                for(p in 1:nrow(peak.table[[ph]])){
                    chr <- peak.table[[ph]][p,"chr"]
                    peak.loc <- peak.table[[ph]][p,"pos"]
                    trait = names(scan.results)[ph]
                    chr.locale <- which(names(map.geno) == chr)

                    if(exclude.zeros){
                        nonzero.idx <- which(map.pheno[,ph] != 0)
                    }else{
                        nonzero.idx <- 1:nrow(map.pheno)
                    }

                    chr.scan <- scan1(rounded.geno[,chr], 
                        map.pheno[nonzero.idx,ph,drop=FALSE], 
                        kinship = map.k[[chr.locale]], addcovar = addcovar,
                        intcovar = intcovar)
                    chr.lod[[idx]] <- chr.scan
                    #plot(chr.scan, map = map);abline(v = peak.loc)

                    effects.scan <- scan1blup(rounded.geno[,chr], 
                        map.pheno[nonzero.idx,ph,drop=FALSE], 
                        kinship = map.k[[chr.locale]], addcovar = addcovar)
                    chr.coef[[idx]] <- effects.scan
                    #plot_coefCC(effects.scan, map = map);abline(v = peak.loc)
                    idx = idx + 1 #increment regardless of whether there is a peak here
                }
                
            }
        }
        saveRDS(chr.lod, chr.lod.file)
        saveRDS(chr.coef, chr.coef.file)
    }else{
        chr.lod <- readRDS(chr.lod.file)
        chr.coef <- readRDS(chr.coef.file)
    }
    result <- list("peak.table" = peak.table, "LOD" = chr.lod, "Coef" = chr.coef)
    return(result)
}

plot_coef_scans <- function(coef.results, map.geno, map.pheno, fdr_results = NULL,
    tab.level = "###", sig_lines = c("Genome-wide", "FDR")){
    
    if(!is.null(fdr_results)){
        sig_lines = sig_lines[1]
        line.idx <- grep(sig_lines, colnames(fdr_results))
    }

    peak.table <- coef.results$peak.table
    chr.lod <- coef.results$LOD
    chr.coef <- coef.results$Coef

    idx <- 1
    for(ph in 1:length(peak.table)){
        if(nrow(peak.table[[ph]]) != 0){
            for(p in 1:nrow(peak.table[[ph]])){
                par(mfrow = c(2,1))
                chr <- peak.table[[ph]][p,"chr"]
                trait <- colnames(map.pheno)[ph]
                peak.loc <- peak.table[[ph]][p,"pos"]
                chr.locale <- which(names(map.geno) == chr)
                
                cat(tab.level, trait, "Chr", chr, "\n")

                if(!is.null(fdr_results)){
                    ymax <- max(c(chr.lod[[idx]], fdr_results[ph,line.idx]))
                }else{
                    ymax <- max(chr.lod[[idx]])
                }
                plot(chr.lod[[idx]], map = map, main = paste(trait, "Chr", chr), 
                    ylim = c(0, ymax*1.05))
                if(!is.null(fdr_results)){
                    abline(h = fdr_results[ph,line.idx])
                
                    plot.dim <- par("usr")
                    par(xpd = TRUE)
                    text(x = plot.dim[2], y = fdr_results[ph,line.idx], 
                        labels = gsub(paste0(sig_lines, " "), "", colnames(fdr_results)[line.idx]), 
                        cex = 0.5, adj = 0)
                }
                par(xpd = FALSE)


                plot_coefCC(chr.coef[[idx]], map = map, main = paste(trait, "Chr", chr),
                    col = strain.colors)
                abline(v = peak.loc, lwd = 2)

                idx = idx + 1
                cat("\n\n")
            }
        }
    }
}

```

```{r map_cds, warning = FALSE}
cds.scans <- map_pheno(expanded.genoprobs, mapping.pheno, exp.K, 
    addcovar = covar, exclude.zeros = exclude.zeros, 
    results.file = file.path(results.dir, "scan1_results_cds.RDS"))

if(run_permutations){
    cds.perm <- perm_scans(expanded.genoprobs, mapping.pheno, exp.K,
        cds.scans, addcovar = covar, groups = names(expanded.idx), 
        exclude.zeros = exclude.zeros, nperm = nperm, 
        results.file = file.path(results.dir, "scan1perm_results_cds.RDS"))
}
```


### CDS by individual LOD traces {.tabset .tabset-fade .tabset-pills}

```{r plot_cds_scans, fig.width = 9, fig.height = 5, warning = FALSE, results = "asis"}
#plot the scans, and FDR results
if(run_permutations){
    fdr_summaries_cds <- plot_fdr_fun(cds.scans, cds.perm, 
        tab.level = "####")
}else{
    for(i in 1:length(cds.scans)){
        cat("####", names(cds.scans)[i], "\n")
        plot(cds.scans[[i]], map = map)
        cat("\n\n")
    }
}
```

### CDS by individual allele effects {.tabset .tabset-fade .tabset-pills}

The following plot shows the allele effects for the Chr 14
QTL for Global CDS. The full chromosome has a lot of allele 
frequency weirdness on it. There are two plots below. One 
of the full chromosome, and another that captures as much 
of the QTL as possible without showing the weirdness.

```{r global_detail, fig.height = 8, fig.width = 8}
#round genotypes to squash out the wild associations we 
#get with teeny tiny probabilities
rounded.geno <- expanded.genoprobs
for(i in 1:length(rounded.geno)){
    rounded.geno[[i]] <- round(rounded.geno[[i]], 2)
}

chr = 14
global.lod <- scan1(rounded.geno[,chr], mapping.pheno[,"Global"], exp.K[[chr]],
    addcovar = covar)
global.coef <- scan1coef(rounded.geno[,chr], mapping.pheno[,"Global"], exp.K[[chr]],
    addcovar = covar)

plot_coefCC(global.coef, map = map, scan1_output = global.lod,
    ylim = c(-2, 2), col = strain.colors, main = "Global CDS full Chr 14",
    top_panel_prop = 0.5)


plot_coefCC(global.coef, map = map, scan1_output = global.lod,
    ylim = c(-2, 2), col = strain.colors, xlim = c(103e6, 119e6),
    main = "Global CDS Chr 14 QTL Window", top_panel_prop = 0.5)


```

```{r scan_coef, fig.width = 7, fig.height = 7, results = "asis", eval = FALSE}
cds.coef <- allele_coef(map.geno = expanded.genoprobs, 
    map.pheno = mapping.pheno, map.k = exp.K, addcovar = mapping.covar,
    scan.results = cds.scans,
    lod.threshold = allele.thresh, exclude.zeros = exclude.zeros, 
    chr.lod.file = file.path(results.dir, "Chr.LOD.cds.RDS"), 
    chr.coef.file = file.path(results.dir, "Chr.Coef.cds.RDS"))

#pdf("~/Desktop/test.pdf", width = 7, height = 7)
if(run_permutations){
    plot_coef_scans(coef.results = cds.coef, 
        map.geno = expanded.genoprobs, map.pheno = mapping.pheno, 
        fdr_results = fdr_summaries_cds, tab.level = "####",
        sig_lines = "Genome-wide")
}else{
    plot_coef_scans(coef.results = cds.coef, 
        map.geno = expanded.genoprobs, map.pheno = mapping.pheno, 
        fdr_results = NULL, tab.level = "####",
        sig_lines = "Genome-wide")
}

#dev.off()
```

### LOD intervals {.tabset .tabset-fade .tabset-pills} 

The following tables show LOD peak intervals for the top 3 peaks from 
each trait.


```{r lod_peaks, results = "asis"}
top.n <- 3
for(ph in 1:length(cds.scans)){
    cat("####", names(cds.scans)[ph], "\n")
    peak.table <- find_peaks(cds.scans[[ph]], map = map, prob = 0.95)
    lod.order <- order(peak.table[,"lod"], decreasing = TRUE)
    print(kable(peak.table[lod.order[1:top.n],]))
    cat("\n\n")
}
```

## Map CDS with Strain Average (Sex Additive) 

We also used strain averages to map CDS. We calculated
the strain averages individually for each sex and used
sex as a covariate.

First we generated strain-mean versions of the genoprobs
and kinship matrices and duplicated each row for the two sexes.

```{r assign_pheno}
#try calculating strain averages from raw data
mapping.pheno <- num.cds[pheno.idx,]
```

```{r calc_avg_pheno}
#calculate average phenotypes and construct new
#genoprobs and kinship for the mean values.
genoprob.strain <- sapply(strsplit(rownames(mapping.genoprobs[[1]]), "/", fixed = TRUE), function(x) x[1])
strain.by.sex <- cbind(rep(genoprob.strain, each = 2), rep(c("F", "M"), length(genoprob.strain)))
ind.labels <- apply(strain.by.sex, 1, function(x) paste(x, collapse = "_"))
mean.genoprobs <- mapping.genoprobs
mean.K <- mapping.K
for(i in 1:length(mean.genoprobs)){
    strain.idx <- match(strain.by.sex[,1], genoprob.strain)
    mean.genoprobs[[i]] <- mapping.genoprobs[[i]][strain.idx,,]
    rownames(mean.genoprobs[[i]]) <- ind.labels
    mean.K[[i]] <- mapping.K[[i]][strain.idx, strain.idx]
    rownames(mean.K[[i]]) <- colnames(mean.K[[i]]) <- ind.labels
}

mean.pheno <- t(apply(strain.by.sex, 1, 
    function(x) colMeans(mapping.pheno[intersect(which(mapping.factors[,1] == x[1]), 
    which(mapping.factors[,2] == x[2])),], na.rm = TRUE)))
rownames(mean.pheno) <- ind.labels

mean.covar <- matrix(as.numeric(as.factor(strain.by.sex[,2])), ncol = 1)
rownames(mean.covar) <- ind.labels

#mean.pheno <- mean.pheno.old[which(!is.na(rowSums(mean.pheno.old))),]
#norm.mean.pheno <- apply(mean.pheno.old, 2, rankZ)
norm.mean.pheno <- mean.pheno
```

```{r map_cds_avg, warning = FALSE}
#do not exclude zeros for stain averages. These don't have
#the same spike in the distribution
cds.avg.scans.sex.add <- map_pheno(mean.genoprobs, norm.mean.pheno, mean.K, 
    exclude.zeros = FALSE, addcovar = mean.covar,
    results.file = file.path(results.dir, "scan1_results_cds_avg.RDS"))

if(run_permutations){
    cds.avg.scans.sex.add.perm <- perm_scans(mean.genoprobs, norm.mean.pheno, mean.K,
        cds.avg.scans.sex.add, groups = NULL, exclude.zeros = FALSE, 
        nperm = nperm, results.file = file.path(results.dir, "scan1perm_results_cds_avg.RDS"))
}
```

### LOD Traces {.tabset .tabset-fade .tabset-pills}

The following plots show the LOD traces for the strain averages of 
CDS and the significance thresholds.

```{r strain_avg_plots, fig.width = 9, fig.height = 5, results = "asis", warning = FALSE}
#pdf("~/Desktop/test.pdf")
if(run_permutations){
    fdr_summaries_sev_avg <- plot_fdr_fun(cds.avg.scans.sex.add, cds.avg.scans.sex.add.perm,
        tab.level = "####")
}else{
    for(i in 1:length(cds.avg.scans.sex.add)){
        cat("####", names(cds.avg.scans.sex.add)[i], "\n")
        plot(cds.avg.scans.sex.add[[i]], map = map, main = names(cds.avg.scans.sex.add)[i])
        cat("\n\n")
    }
}
#dev.off()
```

### Strain Average Allele Effects {.tabset .tabset-fade .tabset-pills}

```{r scan_coef_by_strain, fig.width = 7, fig.height = 7, results = "asis", eval = FALSE}

cds.avg.coef.sex.add <- allele_coef(map.geno = mean.genoprobs, 
    map.pheno = norm.mean.pheno, map.k = mean.K, scan.results = cds.avg.scans.sex.add,
    addcovar = mean.covar,
    lod.threshold = allele.thresh, exclude.zeros = FALSE, 
    chr.lod.file = file.path(results.dir, "Chr.LOD.cds.Avg.RDS"), 
    chr.coef.file = file.path(results.dir, "Chr.Coef.cds.Avg.RDS"))

if(run_permutations){
    #pdf("~/Desktop/test.pdf", width = 7, height = 7)
    plot_coef_scans(coef.results = cds.avg.coef.sex.add, 
        map.geno = mean.genoprobs, map.pheno = norm.mean.pheno, 
        fdr_results = fdr_summaries_sev_avg, tab.level = "####",
        sig_lines = "Genome-wide")
}else{
    plot_coef_scans(coef.results = cds.avg.coef.sex.add, 
        map.geno = mean.genoprobs, map.pheno = norm.mean.pheno, 
        fdr_results = NULL, tab.level = "####",
        sig_lines = "Genome-wide")
}

#dev.off()
```

### Strain Average LOD intervals {.tabset .tabset-fade .tabset-pills}

The following tables show LOD peak intervals for the top 3 peaks from 
each trait.


```{r lod_peaks_avg, results = "asis"}
top.n <- 3
for(ph in 1:length(cds.avg.scans.sex.add)){
    cat("####", names(cds.avg.scans.sex.add)[ph], "\n")
    peak.table <- find_peaks(cds.avg.scans.sex.add[[ph]], map = map, prob = 0.95)
    lod.order <- order(peak.table[,"lod"], decreasing = TRUE)
    print(kable(peak.table[lod.order[1:top.n],]))
    cat("\n\n")
}
```


## Map CDS with Strain Average (Sex Interacting)

We also used sex as an interacting covariate when
mapping CDS.

```{r map_cds_avg_by_sex, warning = FALSE}
#do not exclude zeros when using strain means. They
#don't have the same spike in the distribution
cds.avg.scans.sex.int <- map_pheno(mean.genoprobs, norm.mean.pheno, mean.K, 
    exclude.zeros = FALSE, addcovar = mean.covar, intcovar = mean.covar,
    results.file = file.path(results.dir, "scan1_results_cds_avg_by_sex_int.RDS"))

if(run_permutations){
    perm.groups <- strain.by.sex[,1]
    cds.avg.perm.sex.add <- perm_scans(map.geno = mean.genoprobs, 
        map.pheno = norm.mean.pheno, map.k = mean.K,
        scan1.results = cds.avg.scans.sex.add, addcovar = mean.covar, 
        groups = perm.groups, exclude.zeros = FALSE, nperm = nperm, 
        results.file = file.path(results.dir, "scan1perm_results_cds_avg_sex.RDS"))

    cds.avg.perm.sex.int <- perm_scans(map.geno = mean.genoprobs, 
        map.pheno = norm.mean.pheno, map.k = mean.K, max.exp.lod = 40,
        scan1.results = cds.avg.scans.sex.int, addcovar = covar, intcovar = mean.covar,
        groups = perm.groups, exclude.zeros = FALSE, nperm = nperm,
        results.file = file.path(results.dir, "scan1perm_results_cds_avg_sex_int.RDS"))
}
```

### Interactive and Additive Together {.tabset .tabset-fade .tabset-pills}

The following plots show the two LOD traces plotted on the same
plot with significance thresholds.

```{r plot_with_sig, fig.width = 9, fig.height = 5, results = "asis", warning = FALSE}

for(i in 1:length(cds.avg.scans.sex.int)){
    cat("####", names(cds.avg.scans.sex.int)[i],  "\n")
    if(run_permutations){
        sig.levels.int <- fdr_summarize(cds.avg.perm.sex.int[[i]], fdr_cl = 0.95, 
            geno_sig = alpha, fdr_thresh = c(0.1, 0.2, 0.4), 
            plot = FALSE)
        sig.levels.add <- fdr_summarize(cds.avg.perm.sex.add[[i]], fdr_cl = 0.95, 
            geno_sig = alpha, fdr_thresh = c(0.1, 0.2, 0.4), 
            plot = FALSE)
        ymax <- max(c(cds.avg.scans.sex.int[[i]][,1], sig.levels.add[1], sig.levels.int[1]), na.rm = TRUE)*1.05
    }
    if(!run_permutations || !is.finite(ymax)){
        ymax <- max(c(cds.avg.scans.sex.int[[i]][,1]))*1.05
    }
    plot(cds.avg.scans.sex.int[[i]], map = map, col = "red", 
        main = names(cds.avg.scans.sex.add)[i], ylim = c(0, ymax))
    if(run_permutations){
        abline(h = sig.levels.int, lty = 1:2, col = "red")
    }
    plot(cds.avg.scans.sex.add[[i]], map = map, add = TRUE)
    if(run_permutations){
        abline(h = sig.levels.add, lty = 1:2, col = "darkblue")
    }
    cat("\n\n")
}

```

### Interactive and Additive Differences {.tabset .tabset-fade .tabset-pills}

The figures below show the LOD scores for the additive model 
subtracted off the interactive model. The horizontal line
is the maximum of the permuted values of the additive model
subtracted off the maximum of the permuted values of the
interactive model. This isn't exactly the significance threshold
for a locus that significantly interacts with sex, but it 
gives us a rough idea of where any interacting loci are
most likely to reside.

```{r int_test, fig.width = 9, fig.height = 5, results = "asis"}
for(i in 1:length(cds.avg.scans.sex.add)){
    cat("####", names(cds.avg.scans.sex.add)[i], "\n")
    int.diff <- cds.avg.scans.sex.int[[i]] - cds.avg.scans.sex.add[[i]]
    ylim <- c(min(int.diff[,1])*1.05, max(int.diff[,1])*1.05)
    plot(int.diff, map = map, 
    main = paste(names(cds.avg.scans.sex.add)[i], "(Interactive - Additive)"), 
        ylim = ylim)

    if(run_permutations){
        int.p.dist <- -log10(cds.avg.perm.sex.int[[i]]$min_p)
        add.p.dist <- -log10(cds.avg.perm.sex.add[[i]]$min_p)
        mean.diff <- max(int.p.dist) - max(add.p.dist)
        abline(h = mean.diff)
    }
    cat("\n\n")
}


```

## Incidence {.tabset .tabset-fade .tabset-pills}

Emily calculated an incidence level for each strain as a whole
and separately by sex. Incidence values by strain are as follows.

```{r incidence, fig.width = 5, fig.height = 7, results = "asis"}

for(i in 1:length(incidence)){
    cat("###", names(incidence)[i], "\n")
    imageWithText(incidence[[i]], main = names(incidence)[i], use.pheatmap.colors = TRUE)
    cat("\n\n")
}
```


## Map Incidence

We also want to map incidence at the strain level.
There are three incidence matrices. One has the incidence
for each strain overall. The other two are split by sex.

We mapped the overall incidence per strain on its own.
Then we combined the incidence matrices split by sex 
so we could use sex as an additive and interactive 
covariate as we did with CDS.


```{r avg_geno_k}
#make genoprobs object and a kinship object for 
#the combined incidence matrix

strain.genoprobs <- mean.genoprobs
strain.K <- mean.K

just.strain <- sapply(strsplit(rownames(mean.genoprobs[[1]]), "_"), function(x) x[1])
all.cc.strains <- unique(just.strain)
strain.idx <- match(mapping.strains, just.strain)
strain.idx <- strain.idx[which(!is.na(strain.idx))]

for(i in 1:length(mean.genoprobs)){
    strain.genoprobs[[i]] <- mean.genoprobs[[i]][strain.idx,,]
    rownames(strain.genoprobs[[i]]) <- mapping.strains
    strain.K[[i]] <- mean.K[[i]][strain.idx, strain.idx]
    rownames(strain.K[[i]]) <- colnames(strain.K[[i]]) <- mapping.strains
}

```

Make an overall incidence per strain matrix
and another that has both sexes in it so we 
can play the additive/interactive game again.

We rank Z normalized the columns of each matrix
before mapping.

```{r make_mats}
incidence.strains <- rownames(incidence$incidence_strain)
incidence.strains <- gsub("/", "", gsub(" ", "", incidence.strains))
overall.inc <- apply(incidence$incidence_strain, 2, rankZ)

inc.by.sex <- rbind(incidence$incidence_female, incidence$incidence_male)
inc.by.sex <- apply(inc.by.sex, 2, rankZ)
rownames(inc.by.sex) <- paste(incidence.strains, 
    c(rep("F", nrow(incidence$incidence_female)), rep("M", nrow(incidence$incidence_male))), 
    sep = "_")
incidence.covar <- matrix(1, ncol = 1, nrow = nrow(inc.by.sex))
incidence.covar[1:nrow(incidence$incidence_female)] <- 0
rownames(incidence.covar) <- rownames(inc.by.sex)
```

```{r no_perm}
#set run_permutations to FALSE
#we are not ready to run permutations on incidence yet
#run_permutations = FALSE
```

```{r map_overall_inc, warning = FALSE}

inc.scan.overall <- map_pheno(strain.genoprobs, overall.inc, strain.K, 
    exclude.zeros = FALSE, 
    results.file = file.path(results.dir, "scan1_results_overall_incidence_test.RDS"))

if(run_permutations){    
    incidence.overall.perm <- perm_scans(strain.genoprobs, overall.inc, strain.K,
        inc.scan.overall, groups = NULL, exclude.zeros = FALSE, nperm = nperm,
        results.file = file.path(results.dir, paste0("scan1perm_results_incidence_overall.RDS")))   
}
```

```{r map_inc_by_sex_add, warning = FALSE}
inc.scan.sex.add <- map_pheno(mean.genoprobs, inc.by.sex, mean.K, 
    exclude.zeros = FALSE, addcovar = incidence.covar,
    results.file = file.path(results.dir, "scan1_results_incidence_sex_add.RDS"))

if(run_permutations){    
    incidence.sex.add.perm <- perm_scans(mean.genoprobs, inc.by.sex, mean.K,
        inc.scan.sex.add, addcovar = incidence.covar, groups = NULL, 
        exclude.zeros = FALSE, nperm = nperm,
        results.file = file.path(results.dir, paste0("scan1perm_results_incidence_sex_add.RDS")))   
}
```


```{r map_inc_by_sex_int, warning = FALSE}
inc.scan.sex.int <- map_pheno(mean.genoprobs, inc.by.sex, mean.K, 
    exclude.zeros = FALSE, addcovar = incidence.covar, intcovar = incidence.covar,
    results.file = file.path(results.dir, "scan1_results_incidence_sex_int.RDS"))

if(run_permutations){    
    incidence.sex.int.perm <- perm_scans(mean.genoprobs, inc.by.sex, mean.K,
        inc.scan.sex.add, groups = NULL, exclude.zeros = FALSE, nperm = nperm,
        addcovar = incidence.covar, intcovar = incidence.covar,
        results.file = file.path(results.dir, paste0("scan1perm_results_incidence_sex_int.RDS")))   
}
```


### LOD traces: Incidence Overall {.tabset .tabset-fade .tabset-pills}

```{r plot_inc_perm_overall, warning = FALSE, fig.height = 5, fig.width = 9, results = "asis"}
#pdf("~/Desktop/test.pdf")
if(run_permutations){
    fdr_summaries_incidence_overall <- plot_fdr_fun(inc.scan.overall, 
    incidence.overall.perm, tab.level = "####")
}else{    
    ymax <- max(sapply(inc.scan.overall, function(x) max(x[,1])))*1.05
    for(i in 1:length(inc.scan.overall)){
        cat("####", names(inc.scan.overall)[i], "\n")
        plot(inc.scan.overall[[i]], map = map, main = names(inc.scan.overall)[i], 
            ylim = c(0, ymax))
        cat("\n\n")
    }
}

#dev.off()
```


### LOD Traces: Incidence With Sex as Interactive Covariate {.tabset .tabset-fade .tabset-pills}


```{r plot_perm_inc, warning = FALSE, fig.height = 5, fig.width = 9, results = "asis"}
#pdf("~/Desktop/test.pdf")
if(run_permutations){
    fdr_summaries_incidence_sex_int <- plot_fdr_fun(inc.scan.sex.int, 
    incidence.sex.int.perm, tab.level = "####")
}else{    
    ymax <- max(sapply(inc.scan.sex.int, function(x) max(x[,1])))*1.05
    for(i in 1:length(inc.scan.sex.int)){
        cat("####", names(inc.scan.sex.int)[i], "\n")
        plot(inc.scan.sex.int[[i]], map = map, main = names(inc.scan.sex.int)[i], 
            ylim = c(0, ymax))
        cat("\n\n")
    }
}

#dev.off()
```

## LOD Traces: Additive and Interactive Together {.tabset .tabset-fade .tabset-pills}

```{r plot_inc_perm_both, warning = FALSE, fig.height = 5, fig.width = 9, results = "asis"}
#pdf("~/Desktop/test.pdf")

for(i in 1:length(inc.scan.sex.int)){
    cat("###", names(inc.scan.sex.int)[i], "\n")
    if(run_permutations){
        ymax <- max(c(inc.scan.sex.int[[i]][,1]), fdr_summaries_incidence_sex_int[i,1:2])*1.05
    }else{
        ymax <- max(c(inc.scan.sex.int[[i]][,1]))*1.05
    }
    plot(inc.scan.sex.int[[i]], map = map, col = "red", 
        main = names(inc.scan.sex.int)[i], ylim = c(0, ymax))
    if(run_permutations){
        abline(h = fdr_summaries_incidence_sex_int[i,1:2], lty = 1:2, col = "red")
    }
    plot(inc.scan.sex.add[[i]], map = map, add = TRUE)
    if(run_permutations){
        abline(h = fdr_summaries_incidence_overall[i,1:2], lty = 1:2, col = "darkblue")
    }

    diff.scan <- inc.scan.sex.int[[i]] - inc.scan.sex.add[[i]]
    plot(diff.scan, map = map, main = "Interactive - Additive")
    if(run_permutations){
        int.p.dist <- -log10(incidence.sex.add.perm[[i]]$min_p)
        add.p.dist <- -log10(incidence.sex.int.perm[[i]]$min_p)
        mean.diff <- max(int.p.dist) - max(add.p.dist)
        abline(h = mean.diff)
    }

    cat("\n\n")
}
#dev.off()
```

## Comparing Scans

There is a question as to whether the scans of similar traits 
in these conditions are sufficiently similar. EAE and 
Classical incidence are correlated in terms of phenotype, 
so their mapping should be similar. 

The following plot shows a heatmap of the correlations between
the incidence phenotypes.

```{r inc_cor, fig.width = 6, fig.height = 6}
inc.cor <- cor(overall.inc, use = "pairwise.complete.obs", method = "spearman")
trait.order <- hclust(dist(inc.cor))$order
pheatmap(inc.cor[trait.order, trait.order], display_numbers = TRUE, 
    main = "Incidence Trait Correlations", cluster_cols = FALSE, cluster_rows = FALSE)
```



The following heatmap shows the correlation between
the maps of incidence. Compare this to the correlation
between measured traits. The maps are less correlated
than the traits, but the pattern of correlations are
very similar.

```{r map_cor, fig.width = 6, fig.height = 6}
map.mat <- sapply(inc.scan.overall, function(x) x[,1])
map.cor <- cor(map.mat, use = "pairwise.complete.obs", method = "spearman")

pheatmap(map.cor[trait.order, trait.order], 
    display_numbers = TRUE, cluster_rows = FALSE, cluster_cols = FALSE)
```

The following plot shows how the mapping and trait correlations
relate to each other. For the most part they are very similar.
The correlations between trait pairs tend to be higher than 
the correlations between mapping pairs, which is what we 
expect. The diagonal line shows y = x, and the horizontal 
and vertical lines show y = 0, and x = 0 respectively.

For the Classical-AR pairs, however, the correlation between
the maps is much higher than the correlations between the traits.
I'm not sure why that would be.

```{r compare_cor, fig.width = 6, fig.height = 6}
trait.pairs <- pair.matrix(colnames(map.mat))
map.trait.cor <- matrix(NA, nrow = nrow(trait.pairs), ncol = 2)
colnames(map.trait.cor) <- c("Trait Correlation", "Mapping Correlation")
for(i in 1:nrow(trait.pairs)){
    map.trait.cor[i,1] <- inc.cor[trait.pairs[i,1], trait.pairs[i,2]]
    map.trait.cor[i,2] <- map.cor[trait.pairs[i,1], trait.pairs[i,2]]
}
pair.names <- apply(trait.pairs, 1, function(x) paste(x, collapse = "-"))
plot(map.trait.cor, pch = 16, ylim = c(-0.2, 0.8), xlim = c(-0.6, 1))
abline(0,1)
abline(h = 0, v = 0)
text(map.trait.cor[,1], map.trait.cor[,2], labels = pair.names, pos = 4,
    cex = 0.5)

```


The following heatmap shows the correlations between
the all mapping run above, including with sex as an
interactive covariate.. EAE and Classical are clustered 
in the LOD traces.

```{r lod_cor, fig.width = 8, fig.height = 8}

overall.lod.mat <- sapply(inc.scan.overall, function(x) x[,1])
colnames(overall.lod.mat) <- paste0(colnames(overall.lod.mat), "_overall")
sex.add.lod.mat <- sapply(inc.scan.sex.add, function(x) x[,1])
colnames(sex.add.lod.mat) <- paste0(colnames(sex.add.lod.mat), "_additive")
sex.int.lod.mat <- sapply(inc.scan.sex.int, function(x) x[,1])
colnames(sex.int.lod.mat) <- paste0(colnames(sex.int.lod.mat), "_interactive")

full.mat <- cbind(overall.lod.mat, sex.add.lod.mat, sex.int.lod.mat)
pheatmap(cor(full.mat))

```

```{r compare_avg_ind, eval = FALSE}
plot(cds.scans[[1]][,1], cds.avg.scans.sex.add[[1]][,1])
```

## Large QTL Allele Effects {.tabset .tabset-fade .tabset-pills}

There are some larger QTL in the incidence scans. Here we look
at some of the allele effects to get an idea of how robust these
QTL are.

```{r large_qtl_allele_effects}

#plot.with.model(inc.scan.overall$"Classical.only"[,1], inc.scan.overall$"AR.only"[,1],
#    xlab = "Classical Only LOD", ylab = "AR Only LOD")

#look at individual large QTL to see if they look spurious
plot_max_allele_effects <- function(trait.name, mapping.geno, mapping.pheno, 
    mapping.K, map, scan.results, chr = NULL, round.digs = 2){
    
    scan.trait.idx <- which(names(scan.results) == trait.name)
    pheno.trait.idx <- which(colnames(mapping.pheno) == trait.name)

    #if no chromosome is specified, take the largest overall LOD score
    if(is.null(chr)){
        max.marker <- names(which.max(scan.results[[scan.trait.idx]][,1]))
    }else{
        chr.idx <- which(names(mapping.geno) == chr)
        marker.chr <- dimnames(mapping.geno[[chr.idx]])[[3]]
        max.marker <- names(which.max(scan.results[[scan.trait.idx]][marker.chr,1]))
    }

    #test a random marker
    #max.marker <- sample(rownames(inc.scan.overall[[trait.idx]]), 1)
    marker.pos <- find_markerpos(map, max.marker)
    marker.geno <- round(pull_genoprobpos(mapping.geno, marker = max.marker), 
        round.digs)
    chr.idx <- which(names(map) == marker.pos[,"chr"])

    common.strains <- intersect(rownames(mapping.pheno), rownames(marker.geno))
    annot.df <- data.frame(mapping.pheno[common.strains,pheno.trait.idx,drop=FALSE])

    trait.order <- order(annot.df[,1])
    ordered.names <- common.strains[trait.order]

    model <- fit1(marker.geno, mapping.pheno[,pheno.trait.idx,drop=FALSE], 
        kinship = mapping.K[[chr.idx]])
    marker.lod <- model$lod
    #barplot(model$coef)

    strain.effects <- apply(marker.geno[common.strains,], 2, function(x) annot.df[which(x > 0),1])
    strain.order <- order(sapply(strain.effects, function(x) median(x, na.rm = TRUE)))

    pheatmap(marker.geno[ordered.names,strain.order], annotation_row = annot.df,
        cluster_rows = FALSE, cluster_cols = FALSE, 
        main = paste(trait.name, "Chr", marker.pos[,"chr"], ":", 
        signif(marker.pos[,"pos"], 2), "Mb"))


    boxplot(strain.effects[strain.order], col = strain.colors[strain.order],
        main = paste(trait.name, "Chr", marker.pos[,"chr"], ":", 
        signif(marker.pos[,"pos"], 2), "Mb\nLOD =", signif(marker.lod, 2)),
        ylab = trait.name)
    abline(h = 0)

    result <- list("marker.geno" = marker.geno, "trait.vals" = annot.df,
        "strain.effects" = strain.effects[strain.order])
    invisible(result)
}
```

### EAE

```{r eae_allele_effects}
trait.name = "EAE"
#pdf(paste0("~/Desktop/test_", trait.name, ".pdf"))
test <- plot_max_allele_effects(trait.name, mapping.geno = strain.genoprobs, 
    mapping.pheno = overall.inc, mapping.K = strain.K, map = map, 
    scan.results = inc.scan.overall)
#dev.off()

```

### Combined Type

```{r combined_allele_effects}
trait.name = "Subtype..Combined.Type"
#pdf(paste0("~/Desktop/test_", trait.name, ".pdf"))
plot_max_allele_effects(trait.name, mapping.geno = strain.genoprobs, 
    mapping.pheno = overall.inc, mapping.K = strain.K, map = map, 
    scan.results = inc.scan.overall)
#dev.off()
```

### Classical Only

```{r classical_allele_effects}
trait.name = "Subtype..Classical.only"
#pdf(paste0("~/Desktop/test_", trait.name, ".pdf"))
plot_max_allele_effects(trait.name, mapping.geno = strain.genoprobs, 
    mapping.pheno = overall.inc, mapping.K = strain.K, map = map, 
    scan.results = inc.scan.overall)
#dev.off()

```


## EAE Chr 4

The plot below shows the classic allele effect plot for
chromosome 4 for EAE incidence. There are some allele
frequency issues just above 60 Mb and again at about 
125 Mb that I've cut out of the image.

```{r inc_allele, fig.width = 8, fig.height = 8}
#round genotypes to squash out the wild associations we 
#get with teeny tiny probabilities
rounded.geno <- strain.genoprobs
for(i in 1:length(rounded.geno)){
    rounded.geno[[i]] <- round(rounded.geno[[i]], 2)
}

eae4.lod <- scan1(rounded.geno[,4], overall.inc[,1], strain.K[[4]])
eae4.coef <- scan1coef(rounded.geno[,4], overall.inc[,1], strain.K[[4]])

plot_coefCC(eae4.coef, map = map, scan1_output = eae4.lod, xlim = c(0,100e6),
    ylim = c(-2, 2), col = strain.colors, top_panel_prop = 0.5, 
    main = "EAE Incidence Chr 4")

plot_coefCC(eae4.coef, map = map, scan1_output = eae4.lod, xlim = c(0,100e6),
    ylim = c(-2, 2), col = strain.colors, top_panel_prop = 0.5,
    main = "EAE Incidence Chr 4 window")


```

## SNPs

For large QTL, that that on Chr 4 for EAE incidence, we 
are interested in identifying individual SNPs that match 
the allele effect patterns. 

We want to see if there are any SNPs in this location 
that match the allele effect pattern. I downloaded the
CC SNPs from the [UNC website](https://csbio.unc.edu/CCstatus/CCGenomes/).
I downloaded the file labeled "Sequenced samples (GigaMUGA 20.7Mb)"
on August 16, 2023.

```{r cc_snps}
snps <- read.csv(here("Data", "SEQgenotypes.csv"))
snp.info <- snps[,c(1:3)]
cc.idx <- lapply(incidence.strains, function(x) grep(x, colnames(snps)))
has.snp <- which(sapply(cc.idx, length) > 0)

snp.table <- snps[,unlist(cc.idx[has.snp])]
colnames(snp.table) <- incidence.strains[has.snp]
```

We isolated the region around the LOD peak, 4 Mb up
and downstream of the peak marker.

```{r subset_snps}

eae.peak <- find_peaks(inc.scan.overall$EAE, map = map, threshold = 7)
peak.chr <- eae.peak[1,"chr"]
peak.pos <- eae.peak[1,"pos"]
bp.buffer <- 21e6 #a buffer on either side of the peak

chr.idx <- which(snp.info[,"chromosome"] == peak.chr)
above.min <- which(snp.info[,"position.b38."] >= peak.pos-bp.buffer)
below.max <- which(snp.info[,"position.b38."] <= peak.pos+bp.buffer)
peak.idx <- Reduce("intersect", list(chr.idx, above.min, below.max))
peak.info <- snp.info[peak.idx,]

peak.snps <- as.matrix(snp.table[peak.idx,])
#there are a bunch of SNPs that are labeled N or H
#We will set these to NA
peak.snps[which(peak.snps == "N")] <- NA
peak.snps[which(peak.snps == "H")] <- NA
```

We converted the SNP matrix to a numeric matrix.

```{r convert_num}
#convert to numeric. Use the minor allele in this 
#data set at the minor allele

num.snps <- matrix(NA, nrow = nrow(peak.snps), ncol = ncol(peak.snps))
dimnames(num.snps) <- dimnames(peak.snps)
for(i in 1:nrow(peak.snps)){
    snp.calls <- peak.snps[i,]
    u_snps <- unique(snp.calls[which(!is.na(snp.calls))])
    if(length(u_snps) == 0){next()}
    snp_freq <- sapply(u_snps, function(x) length(which(snp.calls == x)))
    min.allele <- which.min(snp_freq)
    #assign minor allele
    num.snps[i,which(snp.calls == names(min.allele))] <- 0
    #if there is another allele, assign it 1
    if(length(u_snps) > 1){
        maj.allele <- setdiff(names(snp_freq), names(min.allele))
        num.snps[i,which(snp.calls == maj.allele)] <- 1
    }
}
```

```{r ordered_snps, eval = FALSE}
common.ind <- intersect(colnames(num.snps), rownames(overall.inc))
eae_order <- order(overall.inc[common.ind,1])
eae_df <- data.frame("EAE" = overall.inc[common.ind,1])
pheatmap(t(num.snps[,common.ind[eae_order]]), cluster_rows = FALSE, cluster_cols = FALSE,
    show_colnames = FALSE, annotation_row = eae_df)

ind.cor <- cor(num.snps, use = "pairwise.complete.obs")
pheatmap(ind.cor)
marker.cor <- cor(t(num.snps), use = "pairwise.complete.obs")
pheatmap(marker.cor, cluster_rows = FALSE, cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE)
```

And used qtl2 to scan the SNPs.

```{r snp_to_genoprobs}
snp.geno <- abind(num.snps, 1-num.snps, along = 3)
snp.genoprobs <- list(aperm(snp.geno, c(2,3,1)))
dimnames(snp.genoprobs[[1]])[[2]] <- c("A", "B")
names(snp.genoprobs) <- peak.chr
attr(snp.genoprobs, "crosstype") <- "risib"
attr(snp.genoprobs, "is_x_chr") <- c("4" = FALSE)
attr(snp.genoprobs, "alleles") <- c("A", "B")
attr(snp.genoprobs, "alleleprobs") <- FALSE
attr(snp.genoprobs, "class") <- c("calc_genoprob", "list")

rownames(overall.inc) <- str_squish(rownames(overall.inc))
```

There are no individual SNPs that explain the haplotype
effects in the QTL. The peak of the Chr 4 QTL is marked
by the red line. The horizontal black line shows p = 0.01.
Multiple SNPs in the region pass this threshold, but none
stand out as particularly interesting.

```{r scan_snps, fig.width = 7, fig.height = 4}
snp.scan <- scan1(snp.genoprobs, overall.inc[,1,drop=FALSE])
snp.scan.perm <- scan1perm(snp.genoprobs, overall.inc[,1,drop=FALSE], n_perm = 100)
plot(as.numeric(peak.info[,3])/1e6, snp.scan[,1], type = "l",
    xlab = "Chromosome 4 Position (Mb)", ylab = "SNP LOD", ylim = c(0,3))
abline(v = peak.pos/1e6, col = "red")
abline(h = summary(snp.scan.perm, alpha = alpha), lty = c(1,2))
```

### All SNPs

We are also interested in a full scan of the SNPs to see if there
is anything interesting in the genome that we did not see in the
original scan.

```{r all_snps}
u_chr <- c(1:19, "X")

peak.info <- snp.info
peak.snps <- as.matrix(snp.table)
#there are a bunch of SNPs that are labeled N or H
#We will set these to NA
peak.snps[which(peak.snps == "N")] <- NA
peak.snps[which(peak.snps == "H")] <- NA


num.snps <- matrix(NA, nrow = nrow(peak.snps), ncol = ncol(peak.snps))
dimnames(num.snps) <- dimnames(peak.snps)
for(i in 1:nrow(peak.snps)){
    snp.calls <- peak.snps[i,]
    u_snps <- unique(snp.calls[which(!is.na(snp.calls))])
    if(length(u_snps) == 0){next()}
    snp_freq <- sapply(u_snps, function(x) length(which(snp.calls == x)))
    min.allele <- which.min(snp_freq)
    #assign minor allele
    num.snps[i,which(snp.calls == names(min.allele))] <- 0
    #if there is another allele, assign it 1
    if(length(u_snps) > 1){
        maj.allele <- setdiff(names(snp_freq), names(min.allele))
        num.snps[i,which(snp.calls == maj.allele)] <- 1
    }
}

chr_idx <- lapply(u_chr, function(x) which(snp.info[,"chromosome"] == x))
snp.geno <- lapply(chr_idx, function(x) abind(num.snps[x,], 1-num.snps[x,], along = 3))
for(ch in 1:length(u_chr)){
    snp.geno[[ch]] <- aperm(snp.geno[[ch]], c(2,3,1))
    dimnames(snp.geno[[1]])[[2]] <- c("A", "B")
}
names(snp.geno) <- u_chr
attr(snp.geno, "crosstype") <- "risib"
is_x <- c(rep(FALSE, 19), TRUE)
names(is_x) <- u_chr
attr(snp.geno, "is_x_chr") <- is_x
attr(snp.geno, "alleles") <- c("A", "B")
attr(snp.geno, "alleleprobs") <- FALSE
attr(snp.geno, "class") <- c("calc_genoprob", "list")

rownames(overall.inc) <- str_squish(rownames(overall.inc))

snp.scan <- scan1(snp.geno, overall.inc[,1,drop=FALSE])
snp.scan.perm <- scan1perm(snp.geno, overall.inc[,1,drop=FALSE], n_perm = 100)

sig.lines <- summary(snp.scan.perm, alpha = alpha)

pdf(here("Results", "SNP_Scan.pdf"), width = 30, height = 5)
layout(matrix(c(1:20), nrow = 1))
ymax <- max(c(snp.scan[,1], sig.lines[,1]), na.rm = TRUE)*1.2
for(ch in 1:length(u_chr)){
    chr.table <- snp.info[chr_idx[[ch]],]

    if(ch == 1){
    par(mar = c(4,4,4,0))
    }else{
        par(mar = c(4,0,4,0))
    }
    
    chr.min <- min(as.numeric(chr.table[,3])/1e6)
    chr.max <- max(as.numeric(chr.table[,3])/1e6)

    plot.new()
    plot.window(xlim = c(chr.min, chr.max), ylim = c(0, ymax))
    if(ch %% 2 == 0){
        draw.rectangle(chr.min, chr.max, 0, ymax, fill = "lightgray", border.col = NA)
    }

    points(as.numeric(chr.table[,3])/1e6, snp.scan[chr_idx[[ch]],1], type = "h")
    axis(1)
    mtext(u_chr[ch], side = 1, line = 2.5)

    if(ch == 1){
        axis(2)
    }


    abline(h = sig.lines[,1], lty = c(1,2))
}

mtext("EAE", side = 3, outer = TRUE, line = -2.5)
dev.off()
```